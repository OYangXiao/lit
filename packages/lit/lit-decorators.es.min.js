const legacyCustomElement = (tagName, clazz) => {
  customElements.define(tagName, clazz);
  return clazz;
};

const standardCustomElement = (tagName, descriptor) => {
  const {kind: kind, elements: elements} = descriptor;
  return {
    kind: kind,
    elements: elements,
    finisher(clazz) {
      customElements.define(tagName, clazz);
    },
  };
};

const customElement = (tagName) => (classOrDescriptor) =>
  typeof classOrDescriptor === 'function'
    ? legacyCustomElement(tagName, classOrDescriptor)
    : standardCustomElement(tagName, classOrDescriptor);

const standardProperty = (options, element) => {
  if (
    element.kind === 'method' &&
    element.descriptor &&
    !('value' in element.descriptor)
  ) {
    return {
      ...element,
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      },
    };
  } else {
    return {
      kind: 'field',
      key: Symbol(),
      placement: 'own',
      descriptor: {},
      originalKey: element.key,
      initializer() {
        if (typeof element.initializer === 'function') {
          this[element.key] = element.initializer.call(this);
        }
      },
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      },
    };
  }
};

const legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};

function property(options) {
  return (protoOrDescriptor, name) =>
    name !== undefined
      ? legacyProperty(options, protoOrDescriptor, name)
      : standardProperty(options, protoOrDescriptor);
}

function state(options) {
  return property({
    ...options,
    state: true,
  });
}

const decorateProperty =
  ({finisher: finisher, descriptor: descriptor}) =>
  (protoOrDescriptor, name) => {
    var _a;
    if (name !== undefined) {
      const ctor = protoOrDescriptor.constructor;
      if (descriptor !== undefined) {
        Object.defineProperty(protoOrDescriptor, name, descriptor(name));
      }
      finisher === null || finisher === void 0 ? void 0 : finisher(ctor, name);
    } else {
      const key =
        (_a = protoOrDescriptor.originalKey) !== null && _a !== void 0
          ? _a
          : protoOrDescriptor.key;
      const info =
        descriptor != undefined
          ? {
              kind: 'method',
              placement: 'prototype',
              key: key,
              descriptor: descriptor(protoOrDescriptor.key),
            }
          : {
              ...protoOrDescriptor,
              key: key,
            };
      if (finisher != undefined) {
        info.finisher = function (ctor) {
          finisher(ctor, key);
        };
      }
      return info;
    }
  };

function eventOptions(options) {
  return decorateProperty({
    finisher: (ctor, name) => {
      Object.assign(ctor.prototype[name], options);
    },
  });
}

function query(selector, cache) {
  return decorateProperty({
    descriptor: (name) => {
      const descriptor = {
        get() {
          var _a, _b;
          return (_b =
            (_a = this.renderRoot) === null || _a === void 0
              ? void 0
              : _a.querySelector(selector)) !== null && _b !== void 0
            ? _b
            : null;
        },
        enumerable: true,
        configurable: true,
      };
      if (cache) {
        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
        descriptor.get = function () {
          var _a, _b;
          if (this[key] === undefined) {
            this[key] =
              (_b =
                (_a = this.renderRoot) === null || _a === void 0
                  ? void 0
                  : _a.querySelector(selector)) !== null && _b !== void 0
                ? _b
                : null;
          }
          return this[key];
        };
      }
      return descriptor;
    },
  });
}

function queryAll(selector) {
  return decorateProperty({
    descriptor: (_name) => ({
      get() {
        var _a, _b;
        return (_b =
          (_a = this.renderRoot) === null || _a === void 0
            ? void 0
            : _a.querySelectorAll(selector)) !== null && _b !== void 0
          ? _b
          : [];
      },
      enumerable: true,
      configurable: true,
    }),
  });
}

function queryAsync(selector) {
  return decorateProperty({
    descriptor: (_name) => ({
      async get() {
        var _a;
        await this.updateComplete;
        return (_a = this.renderRoot) === null || _a === void 0
          ? void 0
          : _a.querySelector(selector);
      },
      enumerable: true,
      configurable: true,
    }),
  });
}

var _a;

const global = window;

const slotAssignedElements =
  ((_a = global.HTMLSlotElement) === null || _a === void 0
    ? void 0
    : _a.prototype.assignedElements) != null
    ? (slot, opts) => slot.assignedElements(opts)
    : (slot, opts) =>
        slot
          .assignedNodes(opts)
          .filter((node) => node.nodeType === Node.ELEMENT_NODE);

function queryAssignedElements(options) {
  const {slot: slot, selector: selector} =
    options !== null && options !== void 0 ? options : {};
  return decorateProperty({
    descriptor: (_name) => ({
      get() {
        var _a;
        const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;
        const slotEl =
          (_a = this.renderRoot) === null || _a === void 0
            ? void 0
            : _a.querySelector(slotSelector);
        const elements =
          slotEl != null ? slotAssignedElements(slotEl, options) : [];
        if (selector) {
          return elements.filter((node) => node.matches(selector));
        }
        return elements;
      },
      enumerable: true,
      configurable: true,
    }),
  });
}

function queryAssignedNodes(slotOrOptions, flatten, selector) {
  let slot = slotOrOptions;
  let assignedNodesOptions;
  if (typeof slotOrOptions === 'object') {
    slot = slotOrOptions.slot;
    assignedNodesOptions = slotOrOptions;
  } else {
    assignedNodesOptions = {
      flatten: flatten,
    };
  }
  if (selector) {
    return queryAssignedElements({
      slot: slot,
      flatten: flatten,
      selector: selector,
    });
  }
  return decorateProperty({
    descriptor: (_name) => ({
      get() {
        var _a, _b;
        const slotSelector = `slot${slot ? `[name=${slot}]` : ':not([name])'}`;
        const slotEl =
          (_a = this.renderRoot) === null || _a === void 0
            ? void 0
            : _a.querySelector(slotSelector);
        return (_b =
          slotEl === null || slotEl === void 0
            ? void 0
            : slotEl.assignedNodes(assignedNodesOptions)) !== null &&
          _b !== void 0
          ? _b
          : [];
      },
      enumerable: true,
      configurable: true,
    }),
  });
}

export {
  customElement,
  eventOptions,
  property,
  query,
  queryAll,
  queryAssignedElements,
  queryAssignedNodes,
  queryAsync,
  state,
};
//# sourceMappingURL=lit-decorators.es.min.js.map
