const NODE_MODE$1 = false;

const global$2 = window;

const supportsAdoptingStyleSheets =
  global$2.ShadowRoot &&
  (global$2.ShadyCSS === undefined || global$2.ShadyCSS.nativeShadow) &&
  'adoptedStyleSheets' in Document.prototype &&
  'replace' in CSSStyleSheet.prototype;

const constructionToken = Symbol();

const cssTagCache = new WeakMap();

class CSSResult {
  constructor(cssText, strings, safeToken) {
    this['_$cssResult$'] = true;
    if (safeToken !== constructionToken) {
      throw new Error(
        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'
      );
    }
    this.cssText = cssText;
    this._strings = strings;
  }
  get styleSheet() {
    let styleSheet = this._styleSheet;
    const strings = this._strings;
    if (supportsAdoptingStyleSheets && styleSheet === undefined) {
      const cacheable = strings !== undefined && strings.length === 1;
      if (cacheable) {
        styleSheet = cssTagCache.get(strings);
      }
      if (styleSheet === undefined) {
        (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(
          this.cssText
        );
        if (cacheable) {
          cssTagCache.set(strings, styleSheet);
        }
      }
    }
    return styleSheet;
  }
  toString() {
    return this.cssText;
  }
}

const textFromCSSResult = (value) => {
  if (value['_$cssResult$'] === true) {
    return value.cssText;
  } else if (typeof value === 'number') {
    return value;
  } else {
    throw new Error(
      `Value passed to 'css' function must be a 'css' function result: ` +
        `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +
        `to ensure page security.`
    );
  }
};

const unsafeCSS = (value) =>
  new CSSResult(
    typeof value === 'string' ? value : String(value),
    undefined,
    constructionToken
  );

const css = (strings, ...values) => {
  const cssText =
    strings.length === 1
      ? strings[0]
      : values.reduce(
          (acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1],
          strings[0]
        );
  return new CSSResult(cssText, strings, constructionToken);
};

const adoptStyles = (renderRoot, styles) => {
  if (supportsAdoptingStyleSheets) {
    renderRoot.adoptedStyleSheets = styles.map((s) =>
      s instanceof CSSStyleSheet ? s : s.styleSheet
    );
  } else {
    styles.forEach((s) => {
      const style = document.createElement('style');
      const nonce = global$2['litNonce'];
      if (nonce !== undefined) {
        style.setAttribute('nonce', nonce);
      }
      style.textContent = s.cssText;
      renderRoot.appendChild(style);
    });
  }
};

const cssResultFromStyleSheet = (sheet) => {
  let cssText = '';
  for (const rule of sheet.cssRules) {
    cssText += rule.cssText;
  }
  return unsafeCSS(cssText);
};

const getCompatibleStyle =
  supportsAdoptingStyleSheets || NODE_MODE$1
    ? (s) => s
    : (s) => (s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s);

var _d$1;

var _e;

const global$1 = window;

const trustedTypes$1 = global$1.trustedTypes;

const emptyStringForBooleanAttribute$1 = trustedTypes$1
  ? trustedTypes$1.emptyScript
  : '';

const polyfillSupport$2 = global$1.reactiveElementPolyfillSupport;

const JSCompiler_renameProperty = (prop, _obj) => prop;

const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        value = value ? emptyStringForBooleanAttribute$1 : null;
        break;

      case Object:
      case Array:
        value = value == null ? value : JSON.stringify(value);
        break;
    }
    return value;
  },
  fromAttribute(value, type) {
    let fromValue = value;
    switch (type) {
      case Boolean:
        fromValue = value !== null;
        break;

      case Number:
        fromValue = value === null ? null : Number(value);
        break;

      case Object:
      case Array:
        try {
          fromValue = JSON.parse(value);
        } catch (e) {
          fromValue = null;
        }
        break;
    }
    return fromValue;
  },
};

const notEqual = (value, old) =>
  old !== value && (old === old || value === value);

const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual,
};

const finalized = 'finalized';

class ReactiveElement extends HTMLElement {
  constructor() {
    super();
    this.__instanceProperties = new Map();
    this.isUpdatePending = false;
    this.hasUpdated = false;
    this.__reflectingProperty = null;
    this._initialize();
  }
  static addInitializer(initializer) {
    var _a;
    this.finalize();
    ((_a = this._initializers) !== null && _a !== void 0
      ? _a
      : (this._initializers = [])
    ).push(initializer);
  }
  static get observedAttributes() {
    this.finalize();
    const attributes = [];
    this.elementProperties.forEach((v, p) => {
      const attr = this.__attributeNameForProperty(p, v);
      if (attr !== undefined) {
        this.__attributeToPropertyMap.set(attr, p);
        attributes.push(attr);
      }
    });
    return attributes;
  }
  static createProperty(name, options = defaultPropertyDeclaration) {
    if (options.state) {
      options.attribute = false;
    }
    this.finalize();
    this.elementProperties.set(name, options);
    if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
      const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
      const descriptor = this.getPropertyDescriptor(name, key, options);
      if (descriptor !== undefined) {
        Object.defineProperty(this.prototype, name, descriptor);
      }
    }
  }
  static getPropertyDescriptor(name, key, options) {
    return {
      get() {
        return this[key];
      },
      set(value) {
        const oldValue = this[name];
        this[key] = value;
        this.requestUpdate(name, oldValue, options);
      },
      configurable: true,
      enumerable: true,
    };
  }
  static getPropertyOptions(name) {
    return this.elementProperties.get(name) || defaultPropertyDeclaration;
  }
  static finalize() {
    if (this.hasOwnProperty(finalized)) {
      return false;
    }
    this[finalized] = true;
    const superCtor = Object.getPrototypeOf(this);
    superCtor.finalize();
    if (superCtor._initializers !== undefined) {
      this._initializers = [...superCtor._initializers];
    }
    this.elementProperties = new Map(superCtor.elementProperties);
    this.__attributeToPropertyMap = new Map();
    if (this.hasOwnProperty(JSCompiler_renameProperty('properties'))) {
      const props = this.properties;
      const propKeys = [
        ...Object.getOwnPropertyNames(props),
        ...Object.getOwnPropertySymbols(props),
      ];
      for (const p of propKeys) {
        this.createProperty(p, props[p]);
      }
    }
    this.elementStyles = this.finalizeStyles(this.styles);
    return true;
  }
  static finalizeStyles(styles) {
    const elementStyles = [];
    if (Array.isArray(styles)) {
      const set = new Set(styles.flat(Infinity).reverse());
      for (const s of set) {
        elementStyles.unshift(getCompatibleStyle(s));
      }
    } else if (styles !== undefined) {
      elementStyles.push(getCompatibleStyle(styles));
    }
    return elementStyles;
  }
  static __attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false
      ? undefined
      : typeof attribute === 'string'
      ? attribute
      : typeof name === 'string'
      ? name.toLowerCase()
      : undefined;
  }
  _initialize() {
    var _a;
    this.__updatePromise = new Promise((res) => (this.enableUpdating = res));
    this._$changedProperties = new Map();
    this.__saveInstanceProperties();
    this.requestUpdate();
    (_a = this.constructor._initializers) === null || _a === void 0
      ? void 0
      : _a.forEach((i) => i(this));
  }
  addController(controller) {
    var _a, _b;
    ((_a = this.__controllers) !== null && _a !== void 0
      ? _a
      : (this.__controllers = [])
    ).push(controller);
    if (this.renderRoot !== undefined && this.isConnected) {
      (_b = controller.hostConnected) === null || _b === void 0
        ? void 0
        : _b.call(controller);
    }
  }
  removeController(controller) {
    var _a;
    (_a = this.__controllers) === null || _a === void 0
      ? void 0
      : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        this.__instanceProperties.set(p, this[p]);
        delete this[p];
      }
    });
  }
  createRenderRoot() {
    var _a;
    const renderRoot =
      (_a = this.shadowRoot) !== null && _a !== void 0
        ? _a
        : this.attachShadow(this.constructor.shadowRootOptions);
    adoptStyles(renderRoot, this.constructor.elementStyles);
    return renderRoot;
  }
  connectedCallback() {
    var _a;
    if (this.renderRoot === undefined) {
      this.renderRoot = this.createRenderRoot();
    }
    this.enableUpdating(true);
    (_a = this.__controllers) === null || _a === void 0
      ? void 0
      : _a.forEach((c) => {
          var _a;
          return (_a = c.hostConnected) === null || _a === void 0
            ? void 0
            : _a.call(c);
        });
  }
  enableUpdating(_requestedUpdate) {}
  disconnectedCallback() {
    var _a;
    (_a = this.__controllers) === null || _a === void 0
      ? void 0
      : _a.forEach((c) => {
          var _a;
          return (_a = c.hostDisconnected) === null || _a === void 0
            ? void 0
            : _a.call(c);
        });
  }
  attributeChangedCallback(name, _old, value) {
    this._$attributeToProperty(name, value);
  }
  __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    var _a;
    const attr = this.constructor.__attributeNameForProperty(name, options);
    if (attr !== undefined && options.reflect === true) {
      const converter =
        ((_a = options.converter) === null || _a === void 0
          ? void 0
          : _a.toAttribute) !== undefined
          ? options.converter
          : defaultConverter;
      const attrValue = converter.toAttribute(value, options.type);
      this.__reflectingProperty = name;
      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      }
      this.__reflectingProperty = null;
    }
  }
  _$attributeToProperty(name, value) {
    var _a;
    const ctor = this.constructor;
    const propName = ctor.__attributeToPropertyMap.get(name);
    if (propName !== undefined && this.__reflectingProperty !== propName) {
      const options = ctor.getPropertyOptions(propName);
      const converter =
        typeof options.converter === 'function'
          ? {
              fromAttribute: options.converter,
            }
          : ((_a = options.converter) === null || _a === void 0
              ? void 0
              : _a.fromAttribute) !== undefined
          ? options.converter
          : defaultConverter;
      this.__reflectingProperty = propName;
      this[propName] = converter.fromAttribute(value, options.type);
      this.__reflectingProperty = null;
    }
  }
  requestUpdate(name, oldValue, options) {
    let shouldRequestUpdate = true;
    if (name !== undefined) {
      options = options || this.constructor.getPropertyOptions(name);
      const hasChanged = options.hasChanged || notEqual;
      if (hasChanged(this[name], oldValue)) {
        if (!this._$changedProperties.has(name)) {
          this._$changedProperties.set(name, oldValue);
        }
        if (options.reflect === true && this.__reflectingProperty !== name) {
          if (this.__reflectingProperties === undefined) {
            this.__reflectingProperties = new Map();
          }
          this.__reflectingProperties.set(name, options);
        }
      } else {
        shouldRequestUpdate = false;
      }
    }
    if (!this.isUpdatePending && shouldRequestUpdate) {
      this.__updatePromise = this.__enqueueUpdate();
    }
    return undefined;
  }
  async __enqueueUpdate() {
    this.isUpdatePending = true;
    try {
      await this.__updatePromise;
    } catch (e) {
      Promise.reject(e);
    }
    const result = this.scheduleUpdate();
    if (result != null) {
      await result;
    }
    return !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var _b;
    if (!this.isUpdatePending) {
      return;
    }
    if (!this.hasUpdated);
    if (this.__instanceProperties) {
      this.__instanceProperties.forEach((v, p) => (this[p] = v));
      this.__instanceProperties = undefined;
    }
    let shouldUpdate = false;
    const changedProperties = this._$changedProperties;
    try {
      shouldUpdate = this.shouldUpdate(changedProperties);
      if (shouldUpdate) {
        this.willUpdate(changedProperties);
        (_b = this.__controllers) === null || _b === void 0
          ? void 0
          : _b.forEach((c) => {
              var _a;
              return (_a = c.hostUpdate) === null || _a === void 0
                ? void 0
                : _a.call(c);
            });
        this.update(changedProperties);
      } else {
        this.__markUpdated();
      }
    } catch (e) {
      shouldUpdate = false;
      this.__markUpdated();
      throw e;
    }
    if (shouldUpdate) {
      this._$didUpdate(changedProperties);
    }
  }
  willUpdate(_changedProperties) {}
  _$didUpdate(changedProperties) {
    var _a;
    (_a = this.__controllers) === null || _a === void 0
      ? void 0
      : _a.forEach((c) => {
          var _a;
          return (_a = c.hostUpdated) === null || _a === void 0
            ? void 0
            : _a.call(c);
        });
    if (!this.hasUpdated) {
      this.hasUpdated = true;
      this.firstUpdated(changedProperties);
    }
    this.updated(changedProperties);
  }
  __markUpdated() {
    this._$changedProperties = new Map();
    this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(_changedProperties) {
    return true;
  }
  update(_changedProperties) {
    if (this.__reflectingProperties !== undefined) {
      this.__reflectingProperties.forEach((v, k) =>
        this.__propertyToAttribute(k, this[k], v)
      );
      this.__reflectingProperties = undefined;
    }
    this.__markUpdated();
  }
  updated(_changedProperties) {}
  firstUpdated(_changedProperties) {}
}

_e = finalized;

ReactiveElement[_e] = true;

ReactiveElement.elementProperties = new Map();

ReactiveElement.elementStyles = [];

ReactiveElement.shadowRootOptions = {
  mode: 'open',
};

polyfillSupport$2 === null || polyfillSupport$2 === void 0
  ? void 0
  : polyfillSupport$2({
      ReactiveElement: ReactiveElement,
    });

((_d$1 = global$1.reactiveElementVersions) !== null && _d$1 !== void 0
  ? _d$1
  : (global$1.reactiveElementVersions = [])
).push('1.6.1');

var _d;

const global = window;

const wrap$1 = (node) => node;

const trustedTypes = global.trustedTypes;

const policy = trustedTypes
  ? trustedTypes.createPolicy('lit-html', {
      createHTML: (s) => s,
    })
  : undefined;

const boundAttributeSuffix = '$lit$';

const marker = `lit$${String(Math.random()).slice(9)}$`;

const markerMatch = '?' + marker;

const nodeMarker = `<${markerMatch}>`;

const d = document;

const createMarker$1 = () => d.createComment('');

const isPrimitive$1 = (value) =>
  value === null || (typeof value != 'object' && typeof value != 'function');

const isArray = Array.isArray;

const isIterable = (value) =>
  isArray(value) ||
  typeof (value === null || value === void 0
    ? void 0
    : value[Symbol.iterator]) === 'function';

const SPACE_CHAR = `[ \t\n\f\r]`;

const ATTR_VALUE_CHAR = `[^ \t\n\f\r"'\`<>=]`;

const NAME_CHAR = `[^\\s"'>=/]`;

const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;

const COMMENT_START = 1;

const TAG_NAME = 2;

const DYNAMIC_TAG_NAME = 3;

const commentEndRegex = /-->/g;

const comment2EndRegex = />/g;

const tagEndRegex = new RegExp(
  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`,
  'g'
);

const ENTIRE_MATCH = 0;

const ATTRIBUTE_NAME = 1;

const SPACES_AND_EQUALS = 2;

const QUOTE_CHAR = 3;

const singleQuoteAttrEndRegex = /'/g;

const doubleQuoteAttrEndRegex = /"/g;

const rawTextElement = /^(?:script|style|textarea|title)$/i;

const HTML_RESULT$1 = 1;

const SVG_RESULT$1 = 2;

const ATTRIBUTE_PART = 1;

const CHILD_PART = 2;

const PROPERTY_PART = 3;

const BOOLEAN_ATTRIBUTE_PART = 4;

const EVENT_PART = 5;

const ELEMENT_PART = 6;

const COMMENT_PART = 7;

const tag =
  (type) =>
  (strings, ...values) => ({
    ['_$litType$']: type,
    strings: strings,
    values: values,
  });

const html$1 = tag(HTML_RESULT$1);

const svg$1 = tag(SVG_RESULT$1);

const noChange = Symbol.for('lit-noChange');

const nothing = Symbol.for('lit-nothing');

const templateCache = new WeakMap();

const walker = d.createTreeWalker(d, 129, null, false);

const getTemplateHtml = (strings, type) => {
  const l = strings.length - 1;
  const attrNames = [];
  let html = type === SVG_RESULT$1 ? '<svg>' : '';
  let rawTextEndRegex;
  let regex = textEndRegex;
  for (let i = 0; i < l; i++) {
    const s = strings[i];
    let attrNameEndIndex = -1;
    let attrName;
    let lastIndex = 0;
    let match;
    while (lastIndex < s.length) {
      regex.lastIndex = lastIndex;
      match = regex.exec(s);
      if (match === null) {
        break;
      }
      lastIndex = regex.lastIndex;
      if (regex === textEndRegex) {
        if (match[COMMENT_START] === '!--') {
          regex = commentEndRegex;
        } else if (match[COMMENT_START] !== undefined) {
          regex = comment2EndRegex;
        } else if (match[TAG_NAME] !== undefined) {
          if (rawTextElement.test(match[TAG_NAME])) {
            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');
          }
          regex = tagEndRegex;
        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {
          regex = tagEndRegex;
        }
      } else if (regex === tagEndRegex) {
        if (match[ENTIRE_MATCH] === '>') {
          regex =
            rawTextEndRegex !== null && rawTextEndRegex !== void 0
              ? rawTextEndRegex
              : textEndRegex;
          attrNameEndIndex = -1;
        } else if (match[ATTRIBUTE_NAME] === undefined) {
          attrNameEndIndex = -2;
        } else {
          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;
          attrName = match[ATTRIBUTE_NAME];
          regex =
            match[QUOTE_CHAR] === undefined
              ? tagEndRegex
              : match[QUOTE_CHAR] === '"'
              ? doubleQuoteAttrEndRegex
              : singleQuoteAttrEndRegex;
        }
      } else if (
        regex === doubleQuoteAttrEndRegex ||
        regex === singleQuoteAttrEndRegex
      ) {
        regex = tagEndRegex;
      } else if (regex === commentEndRegex || regex === comment2EndRegex) {
        regex = textEndRegex;
      } else {
        regex = tagEndRegex;
        rawTextEndRegex = undefined;
      }
    }
    const end =
      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';
    html +=
      regex === textEndRegex
        ? s + nodeMarker
        : attrNameEndIndex >= 0
        ? (attrNames.push(attrName),
          s.slice(0, attrNameEndIndex) +
            boundAttributeSuffix +
            s.slice(attrNameEndIndex)) +
          marker +
          end
        : s +
          marker +
          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);
  }
  const htmlResult =
    html + (strings[l] || '<?>') + (type === SVG_RESULT$1 ? '</svg>' : '');
  if (!Array.isArray(strings) || !strings.hasOwnProperty('raw')) {
    let message = 'invalid template strings array';
    throw new Error(message);
  }
  return [
    policy !== undefined ? policy.createHTML(htmlResult) : htmlResult,
    attrNames,
  ];
};

class Template {
  constructor({strings: strings, ['_$litType$']: type}, options) {
    this.parts = [];
    let node;
    let nodeIndex = 0;
    let attrNameIndex = 0;
    const partCount = strings.length - 1;
    const parts = this.parts;
    const [html, attrNames] = getTemplateHtml(strings, type);
    this.el = Template.createElement(html, options);
    walker.currentNode = this.el.content;
    if (type === SVG_RESULT$1) {
      const content = this.el.content;
      const svgElement = content.firstChild;
      svgElement.remove();
      content.append(...svgElement.childNodes);
    }
    while ((node = walker.nextNode()) !== null && parts.length < partCount) {
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attrsToRemove = [];
          for (const name of node.getAttributeNames()) {
            if (
              name.endsWith(boundAttributeSuffix) ||
              name.startsWith(marker)
            ) {
              const realName = attrNames[attrNameIndex++];
              attrsToRemove.push(name);
              if (realName !== undefined) {
                const value = node.getAttribute(
                  realName.toLowerCase() + boundAttributeSuffix
                );
                const statics = value.split(marker);
                const m = /([.?@])?(.*)/.exec(realName);
                parts.push({
                  type: ATTRIBUTE_PART,
                  index: nodeIndex,
                  name: m[2],
                  strings: statics,
                  ctor:
                    m[1] === '.'
                      ? PropertyPart
                      : m[1] === '?'
                      ? BooleanAttributePart
                      : m[1] === '@'
                      ? EventPart
                      : AttributePart,
                });
              } else {
                parts.push({
                  type: ELEMENT_PART,
                  index: nodeIndex,
                });
              }
            }
          }
          for (const name of attrsToRemove) {
            node.removeAttribute(name);
          }
        }
        if (rawTextElement.test(node.tagName)) {
          const strings = node.textContent.split(marker);
          const lastIndex = strings.length - 1;
          if (lastIndex > 0) {
            node.textContent = trustedTypes ? trustedTypes.emptyScript : '';
            for (let i = 0; i < lastIndex; i++) {
              node.append(strings[i], createMarker$1());
              walker.nextNode();
              parts.push({
                type: CHILD_PART,
                index: ++nodeIndex,
              });
            }
            node.append(strings[lastIndex], createMarker$1());
          }
        }
      } else if (node.nodeType === 8) {
        const data = node.data;
        if (data === markerMatch) {
          parts.push({
            type: CHILD_PART,
            index: nodeIndex,
          });
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            parts.push({
              type: COMMENT_PART,
              index: nodeIndex,
            });
            i += marker.length - 1;
          }
        }
      }
      nodeIndex++;
    }
  }
  static createElement(html, _options) {
    const el = d.createElement('template');
    el.innerHTML = html;
    return el;
  }
}

function resolveDirective(part, value, parent = part, attributeIndex) {
  var _a, _b, _c;
  var _d;
  if (value === noChange) {
    return value;
  }
  let currentDirective =
    attributeIndex !== undefined
      ? (_a = parent.__directives) === null || _a === void 0
        ? void 0
        : _a[attributeIndex]
      : parent.__directive;
  const nextDirectiveConstructor = isPrimitive$1(value)
    ? undefined
    : value['_$litDirective$'];
  if (
    (currentDirective === null || currentDirective === void 0
      ? void 0
      : currentDirective.constructor) !== nextDirectiveConstructor
  ) {
    (_b =
      currentDirective === null || currentDirective === void 0
        ? void 0
        : currentDirective['_$notifyDirectiveConnectionChanged']) === null ||
    _b === void 0
      ? void 0
      : _b.call(currentDirective, false);
    if (nextDirectiveConstructor === undefined) {
      currentDirective = undefined;
    } else {
      currentDirective = new nextDirectiveConstructor(part);
      currentDirective._$initialize(part, parent, attributeIndex);
    }
    if (attributeIndex !== undefined) {
      ((_c = (_d = parent).__directives) !== null && _c !== void 0
        ? _c
        : (_d.__directives = []))[attributeIndex] = currentDirective;
    } else {
      parent.__directive = currentDirective;
    }
  }
  if (currentDirective !== undefined) {
    value = resolveDirective(
      part,
      currentDirective._$resolve(part, value.values),
      currentDirective,
      attributeIndex
    );
  }
  return value;
}

class TemplateInstance {
  constructor(template, parent) {
    this._$parts = [];
    this._$disconnectableChildren = undefined;
    this._$template = template;
    this._$parent = parent;
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(options) {
    var _a;
    const {
      el: {content: content},
      parts: parts,
    } = this._$template;
    const fragment = (
      (_a =
        options === null || options === void 0
          ? void 0
          : options.creationScope) !== null && _a !== void 0
        ? _a
        : d
    ).importNode(content, true);
    walker.currentNode = fragment;
    let node = walker.nextNode();
    let nodeIndex = 0;
    let partIndex = 0;
    let templatePart = parts[0];
    while (templatePart !== undefined) {
      if (nodeIndex === templatePart.index) {
        let part;
        if (templatePart.type === CHILD_PART) {
          part = new ChildPart$1(node, node.nextSibling, this, options);
        } else if (templatePart.type === ATTRIBUTE_PART) {
          part = new templatePart.ctor(
            node,
            templatePart.name,
            templatePart.strings,
            this,
            options
          );
        } else if (templatePart.type === ELEMENT_PART) {
          part = new ElementPart(node, this, options);
        }
        this._$parts.push(part);
        templatePart = parts[++partIndex];
      }
      if (
        nodeIndex !==
        (templatePart === null || templatePart === void 0
          ? void 0
          : templatePart.index)
      ) {
        node = walker.nextNode();
        nodeIndex++;
      }
    }
    walker.currentNode = d;
    return fragment;
  }
  _update(values) {
    let i = 0;
    for (const part of this._$parts) {
      if (part !== undefined) {
        if (part.strings !== undefined) {
          part._$setValue(values, part, i);
          i += part.strings.length - 2;
        } else {
          part._$setValue(values[i]);
        }
      }
      i++;
    }
  }
}

class ChildPart$1 {
  constructor(startNode, endNode, parent, options) {
    var _a;
    this.type = CHILD_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = undefined;
    this._$startNode = startNode;
    this._$endNode = endNode;
    this._$parent = parent;
    this.options = options;
    this.__isConnected =
      (_a =
        options === null || options === void 0
          ? void 0
          : options.isConnected) !== null && _a !== void 0
        ? _a
        : true;
  }
  get _$isConnected() {
    var _a, _b;
    return (_b =
      (_a = this._$parent) === null || _a === void 0
        ? void 0
        : _a._$isConnected) !== null && _b !== void 0
      ? _b
      : this.__isConnected;
  }
  get parentNode() {
    let parentNode = wrap$1(this._$startNode).parentNode;
    const parent = this._$parent;
    if (
      parent !== undefined &&
      (parentNode === null || parentNode === void 0
        ? void 0
        : parentNode.nodeType) === 11
    ) {
      parentNode = parent.parentNode;
    }
    return parentNode;
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(value, directiveParent = this) {
    value = resolveDirective(this, value, directiveParent);
    if (isPrimitive$1(value)) {
      if (value === nothing || value == null || value === '') {
        if (this._$committedValue !== nothing) {
          this._$clear();
        }
        this._$committedValue = nothing;
      } else if (value !== this._$committedValue && value !== noChange) {
        this._commitText(value);
      }
    } else if (value['_$litType$'] !== undefined) {
      this._commitTemplateResult(value);
    } else if (value.nodeType !== undefined) {
      this._commitNode(value);
    } else if (isIterable(value)) {
      this._commitIterable(value);
    } else {
      this._commitText(value);
    }
  }
  _insert(node) {
    return wrap$1(wrap$1(this._$startNode).parentNode).insertBefore(
      node,
      this._$endNode
    );
  }
  _commitNode(value) {
    if (this._$committedValue !== value) {
      this._$clear();
      this._$committedValue = this._insert(value);
    }
  }
  _commitText(value) {
    if (
      this._$committedValue !== nothing &&
      isPrimitive$1(this._$committedValue)
    ) {
      const node = wrap$1(this._$startNode).nextSibling;
      node.data = value;
    } else {
      {
        this._commitNode(d.createTextNode(value));
      }
    }
    this._$committedValue = value;
  }
  _commitTemplateResult(result) {
    var _a;
    const {values: values, ['_$litType$']: type} = result;
    const template =
      typeof type === 'number'
        ? this._$getTemplate(result)
        : (type.el === undefined &&
            (type.el = Template.createElement(type.h, this.options)),
          type);
    if (
      ((_a = this._$committedValue) === null || _a === void 0
        ? void 0
        : _a._$template) === template
    ) {
      this._$committedValue._update(values);
    } else {
      const instance = new TemplateInstance(template, this);
      const fragment = instance._clone(this.options);
      instance._update(values);
      this._commitNode(fragment);
      this._$committedValue = instance;
    }
  }
  _$getTemplate(result) {
    let template = templateCache.get(result.strings);
    if (template === undefined) {
      templateCache.set(result.strings, (template = new Template(result)));
    }
    return template;
  }
  _commitIterable(value) {
    if (!isArray(this._$committedValue)) {
      this._$committedValue = [];
      this._$clear();
    }
    const itemParts = this._$committedValue;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      if (partIndex === itemParts.length) {
        itemParts.push(
          (itemPart = new ChildPart$1(
            this._insert(createMarker$1()),
            this._insert(createMarker$1()),
            this,
            this.options
          ))
        );
      } else {
        itemPart = itemParts[partIndex];
      }
      itemPart._$setValue(item);
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      this._$clear(
        itemPart && wrap$1(itemPart._$endNode).nextSibling,
        partIndex
      );
      itemParts.length = partIndex;
    }
  }
  _$clear(start = wrap$1(this._$startNode).nextSibling, from) {
    var _a;
    (_a = this._$notifyConnectionChanged) === null || _a === void 0
      ? void 0
      : _a.call(this, false, true, from);
    while (start && start !== this._$endNode) {
      const n = wrap$1(start).nextSibling;
      wrap$1(start).remove();
      start = n;
    }
  }
  setConnected(isConnected) {
    var _a;
    if (this._$parent === undefined) {
      this.__isConnected = isConnected;
      (_a = this._$notifyConnectionChanged) === null || _a === void 0
        ? void 0
        : _a.call(this, isConnected);
    }
  }
}

class AttributePart {
  constructor(element, name, strings, parent, options) {
    this.type = ATTRIBUTE_PART;
    this._$committedValue = nothing;
    this._$disconnectableChildren = undefined;
    this.element = element;
    this.name = name;
    this._$parent = parent;
    this.options = options;
    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
      this._$committedValue = new Array(strings.length - 1).fill(new String());
      this.strings = strings;
    } else {
      this._$committedValue = nothing;
    }
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value, directiveParent = this, valueIndex, noCommit) {
    const strings = this.strings;
    let change = false;
    if (strings === undefined) {
      value = resolveDirective(this, value, directiveParent, 0);
      change =
        !isPrimitive$1(value) ||
        (value !== this._$committedValue && value !== noChange);
      if (change) {
        this._$committedValue = value;
      }
    } else {
      const values = value;
      value = strings[0];
      let i, v;
      for (i = 0; i < strings.length - 1; i++) {
        v = resolveDirective(this, values[valueIndex + i], directiveParent, i);
        if (v === noChange) {
          v = this._$committedValue[i];
        }
        change ||
          (change = !isPrimitive$1(v) || v !== this._$committedValue[i]);
        if (v === nothing) {
          value = nothing;
        } else if (value !== nothing) {
          value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
        }
        this._$committedValue[i] = v;
      }
    }
    if (change && !noCommit) {
      this._commitValue(value);
    }
  }
  _commitValue(value) {
    if (value === nothing) {
      wrap$1(this.element).removeAttribute(this.name);
    } else {
      wrap$1(this.element).setAttribute(
        this.name,
        value !== null && value !== void 0 ? value : ''
      );
    }
  }
}

class PropertyPart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = PROPERTY_PART;
  }
  _commitValue(value) {
    this.element[this.name] = value === nothing ? undefined : value;
  }
}

const emptyStringForBooleanAttribute = trustedTypes
  ? trustedTypes.emptyScript
  : '';

class BooleanAttributePart extends AttributePart {
  constructor() {
    super(...arguments);
    this.type = BOOLEAN_ATTRIBUTE_PART;
  }
  _commitValue(value) {
    if (value && value !== nothing) {
      wrap$1(this.element).setAttribute(
        this.name,
        emptyStringForBooleanAttribute
      );
    } else {
      wrap$1(this.element).removeAttribute(this.name);
    }
  }
}

class EventPart extends AttributePart {
  constructor(element, name, strings, parent, options) {
    super(element, name, strings, parent, options);
    this.type = EVENT_PART;
  }
  _$setValue(newListener, directiveParent = this) {
    var _a;
    newListener =
      (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null &&
      _a !== void 0
        ? _a
        : nothing;
    if (newListener === noChange) {
      return;
    }
    const oldListener = this._$committedValue;
    const shouldRemoveListener =
      (newListener === nothing && oldListener !== nothing) ||
      newListener.capture !== oldListener.capture ||
      newListener.once !== oldListener.once ||
      newListener.passive !== oldListener.passive;
    const shouldAddListener =
      newListener !== nothing &&
      (oldListener === nothing || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.name, this, oldListener);
    }
    if (shouldAddListener) {
      this.element.addEventListener(this.name, this, newListener);
    }
    this._$committedValue = newListener;
  }
  handleEvent(event) {
    var _a, _b;
    if (typeof this._$committedValue === 'function') {
      this._$committedValue.call(
        (_b =
          (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !==
          null && _b !== void 0
          ? _b
          : this.element,
        event
      );
    } else {
      this._$committedValue.handleEvent(event);
    }
  }
}

class ElementPart {
  constructor(element, parent, options) {
    this.element = element;
    this.type = ELEMENT_PART;
    this._$disconnectableChildren = undefined;
    this._$parent = parent;
    this.options = options;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(value) {
    resolveDirective(this, value);
  }
}

const _$LH = {
  _boundAttributeSuffix: boundAttributeSuffix,
  _marker: marker,
  _markerMatch: markerMatch,
  _HTML_RESULT: HTML_RESULT$1,
  _getTemplateHtml: getTemplateHtml,
  _TemplateInstance: TemplateInstance,
  _isIterable: isIterable,
  _resolveDirective: resolveDirective,
  _ChildPart: ChildPart$1,
  _AttributePart: AttributePart,
  _BooleanAttributePart: BooleanAttributePart,
  _EventPart: EventPart,
  _PropertyPart: PropertyPart,
  _ElementPart: ElementPart,
};

const polyfillSupport$1 = global.litHtmlPolyfillSupport;

polyfillSupport$1 === null || polyfillSupport$1 === void 0
  ? void 0
  : polyfillSupport$1(Template, ChildPart$1);

((_d = global.litHtmlVersions) !== null && _d !== void 0
  ? _d
  : (global.litHtmlVersions = [])
).push('2.7.3');

const render = (value, container, options) => {
  var _a, _b;
  const partOwnerNode =
    (_a =
      options === null || options === void 0
        ? void 0
        : options.renderBefore) !== null && _a !== void 0
      ? _a
      : container;
  let part = partOwnerNode['_$litPart$'];
  if (part === undefined) {
    const endNode =
      (_b =
        options === null || options === void 0
          ? void 0
          : options.renderBefore) !== null && _b !== void 0
        ? _b
        : null;
    partOwnerNode['_$litPart$'] = part = new ChildPart$1(
      container.insertBefore(createMarker$1(), endNode),
      endNode,
      undefined,
      options !== null && options !== void 0 ? options : {}
    );
  }
  part._$setValue(value);
  return part;
};

var _b, _c;

const UpdatingElement = ReactiveElement;

class LitElement extends ReactiveElement {
  constructor() {
    super(...arguments);
    this.renderOptions = {
      host: this,
    };
    this.__childPart = undefined;
  }
  createRenderRoot() {
    var _a;
    var _b;
    const renderRoot = super.createRenderRoot();
    (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0
      ? _a
      : (_b.renderBefore = renderRoot.firstChild);
    return renderRoot;
  }
  update(changedProperties) {
    const value = this.render();
    if (!this.hasUpdated) {
      this.renderOptions.isConnected = this.isConnected;
    }
    super.update(changedProperties);
    this.__childPart = render(value, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var _a;
    super.connectedCallback();
    (_a = this.__childPart) === null || _a === void 0
      ? void 0
      : _a.setConnected(true);
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    (_a = this.__childPart) === null || _a === void 0
      ? void 0
      : _a.setConnected(false);
  }
  render() {
    return noChange;
  }
}

LitElement['finalized'] = true;

LitElement['_$litElement$'] = true;

(_b = globalThis.litElementHydrateSupport) === null || _b === void 0
  ? void 0
  : _b.call(globalThis, {
      LitElement: LitElement,
    });

const polyfillSupport = globalThis.litElementPolyfillSupport;

polyfillSupport === null || polyfillSupport === void 0
  ? void 0
  : polyfillSupport({
      LitElement: LitElement,
    });

const _$LE = {
  _$attributeToProperty: (el, name, value) => {
    el._$attributeToProperty(name, value);
  },
  _$changedProperties: (el) => el._$changedProperties,
};

((_c = globalThis.litElementVersions) !== null && _c !== void 0
  ? _c
  : (globalThis.litElementVersions = [])
).push('3.3.2');

const NODE_MODE = false;

const isServer = NODE_MODE;

const {_ChildPart: ChildPart} = _$LH;

const wrap = (node) => node;

const isPrimitive = (value) =>
  value === null || (typeof value != 'object' && typeof value != 'function');

const TemplateResultType = {
  HTML: 1,
  SVG: 2,
};

const isTemplateResult = (value, type) =>
  type === undefined
    ? (value === null || value === void 0 ? void 0 : value['_$litType$']) !==
      undefined
    : (value === null || value === void 0 ? void 0 : value['_$litType$']) ===
      type;

const isDirectiveResult = (value) =>
  (value === null || value === void 0 ? void 0 : value['_$litDirective$']) !==
  undefined;

const getDirectiveClass = (value) =>
  value === null || value === void 0 ? void 0 : value['_$litDirective$'];

const isSingleExpression = (part) => part.strings === undefined;

const createMarker = () => document.createComment('');

const insertPart = (containerPart, refPart, part) => {
  var _a;
  const container = wrap(containerPart._$startNode).parentNode;
  const refNode =
    refPart === undefined ? containerPart._$endNode : refPart._$startNode;
  if (part === undefined) {
    const startNode = wrap(container).insertBefore(createMarker(), refNode);
    const endNode = wrap(container).insertBefore(createMarker(), refNode);
    part = new ChildPart(
      startNode,
      endNode,
      containerPart,
      containerPart.options
    );
  } else {
    const endNode = wrap(part._$endNode).nextSibling;
    const oldParent = part._$parent;
    const parentChanged = oldParent !== containerPart;
    if (parentChanged) {
      (_a = part._$reparentDisconnectables) === null || _a === void 0
        ? void 0
        : _a.call(part, containerPart);
      part._$parent = containerPart;
      let newConnectionState;
      if (
        part._$notifyConnectionChanged !== undefined &&
        (newConnectionState = containerPart._$isConnected) !==
          oldParent._$isConnected
      ) {
        part._$notifyConnectionChanged(newConnectionState);
      }
    }
    if (endNode !== refNode || parentChanged) {
      let start = part._$startNode;
      while (start !== endNode) {
        const n = wrap(start).nextSibling;
        wrap(container).insertBefore(start, refNode);
        start = n;
      }
    }
  }
  return part;
};

const setChildPartValue = (part, value, directiveParent = part) => {
  part._$setValue(value, directiveParent);
  return part;
};

const RESET_VALUE = {};

const setCommittedValue = (part, value = RESET_VALUE) =>
  (part._$committedValue = value);

const getCommittedValue = (part) => part._$committedValue;

const removePart = (part) => {
  var _a;
  (_a = part._$notifyConnectionChanged) === null || _a === void 0
    ? void 0
    : _a.call(part, false, true);
  let start = part._$startNode;
  const end = wrap(part._$endNode).nextSibling;
  while (start !== end) {
    const n = wrap(start).nextSibling;
    wrap(start).remove();
    start = n;
  }
};

const clearPart = (part) => {
  part._$clear();
};

const PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6,
};

const directive =
  (c) =>
  (...values) => ({
    ['_$litDirective$']: c,
    values: values,
  });

class Directive {
  constructor(_partInfo) {}
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
}

const notifyChildrenConnectedChanged = (parent, isConnected) => {
  var _a, _b;
  const children = parent._$disconnectableChildren;
  if (children === undefined) {
    return false;
  }
  for (const obj of children) {
    (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null ||
    _b === void 0
      ? void 0
      : _b.call(_a, isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};

const removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === undefined) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while (
    (children === null || children === void 0 ? void 0 : children.size) === 0
  );
};

const addDisconnectableToParent = (obj) => {
  for (let parent; (parent = obj._$parent); obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === undefined) {
      parent._$disconnectableChildren = children = new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};

function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== undefined) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}

function notifyChildPartConnectedChanged(
  isConnected,
  isClearingValue = false,
  fromPartIndex = 0
) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === undefined || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}

const installDisconnectAPI = (obj) => {
  var _a, _b;
  var _c, _d;
  if (obj.type == PartType.CHILD) {
    (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0
      ? _a
      : (_c._$notifyConnectionChanged = notifyChildPartConnectedChanged);
    (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0
      ? _b
      : (_d._$reparentDisconnectables = reparentDisconnectables);
  }
};

class AsyncDirective extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = undefined;
  }
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  ['_$notifyDirectiveConnectionChanged'](
    isConnected,
    isClearingDirective = true
  ) {
    var _a, _b;
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        (_a = this.reconnected) === null || _a === void 0
          ? void 0
          : _a.call(this);
      } else {
        (_b = this.disconnected) === null || _b === void 0
          ? void 0
          : _b.call(this);
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  disconnected() {}
  reconnected() {}
}

const forAwaitOf = async (iterable, callback) => {
  for await (const v of iterable) {
    if ((await callback(v)) === false) {
      return;
    }
  }
};

class PseudoWeakRef {
  constructor(ref) {
    this._ref = ref;
  }
  disconnect() {
    this._ref = undefined;
  }
  reconnect(ref) {
    this._ref = ref;
  }
  deref() {
    return this._ref;
  }
}

class Pauser {
  constructor() {
    this._promise = undefined;
    this._resolve = undefined;
  }
  get() {
    return this._promise;
  }
  pause() {
    var _a;
    (_a = this._promise) !== null && _a !== void 0
      ? _a
      : (this._promise = new Promise((resolve) => (this._resolve = resolve)));
  }
  resume() {
    var _a;
    (_a = this._resolve) === null || _a === void 0 ? void 0 : _a.call(this);
    this._promise = this._resolve = undefined;
  }
}

class AsyncReplaceDirective extends AsyncDirective {
  constructor() {
    super(...arguments);
    this.__weakThis = new PseudoWeakRef(this);
    this.__pauser = new Pauser();
  }
  render(value, _mapper) {
    return noChange;
  }
  update(_part, [value, mapper]) {
    if (!this.isConnected) {
      this.disconnected();
    }
    if (value === this.__value) {
      return;
    }
    this.__value = value;
    let i = 0;
    const {__weakThis: weakThis, __pauser: pauser} = this;
    forAwaitOf(value, async (v) => {
      while (pauser.get()) {
        await pauser.get();
      }
      const _this = weakThis.deref();
      if (_this !== undefined) {
        if (_this.__value !== value) {
          return false;
        }
        if (mapper !== undefined) {
          v = mapper(v, i);
        }
        _this.commitValue(v, i);
        i++;
      }
      return true;
    });
    return noChange;
  }
  commitValue(value, _index) {
    this.setValue(value);
  }
  disconnected() {
    this.__weakThis.disconnect();
    this.__pauser.pause();
  }
  reconnected() {
    this.__weakThis.reconnect(this);
    this.__pauser.resume();
  }
}

const asyncReplace = directive(AsyncReplaceDirective);

class AsyncAppendDirective extends AsyncReplaceDirective {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error('asyncAppend can only be used in child expressions');
    }
  }
  update(part, params) {
    this.__childPart = part;
    return super.update(part, params);
  }
  commitValue(value, index) {
    if (index === 0) {
      clearPart(this.__childPart);
    }
    const newPart = insertPart(this.__childPart);
    setChildPartValue(newPart, value);
  }
}

const asyncAppend = directive(AsyncAppendDirective);

class CacheDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._templateCache = new WeakMap();
  }
  render(v) {
    return [v];
  }
  update(containerPart, [v]) {
    if (
      isTemplateResult(this._value) &&
      (!isTemplateResult(v) || this._value.strings !== v.strings)
    ) {
      const partValue = getCommittedValue(containerPart);
      const childPart = partValue.pop();
      let cachedContainerPart = this._templateCache.get(this._value.strings);
      if (cachedContainerPart === undefined) {
        const fragment = document.createDocumentFragment();
        cachedContainerPart = render(nothing, fragment);
        cachedContainerPart.setConnected(false);
        this._templateCache.set(this._value.strings, cachedContainerPart);
      }
      setCommittedValue(cachedContainerPart, [childPart]);
      insertPart(cachedContainerPart, undefined, childPart);
    }
    if (isTemplateResult(v)) {
      if (!isTemplateResult(this._value) || this._value.strings !== v.strings) {
        const cachedContainerPart = this._templateCache.get(v.strings);
        if (cachedContainerPart !== undefined) {
          const partValue = getCommittedValue(cachedContainerPart);
          const cachedPart = partValue.pop();
          clearPart(containerPart);
          insertPart(containerPart, undefined, cachedPart);
          setCommittedValue(containerPart, [cachedPart]);
        }
      }
      this._value = v;
    } else {
      this._value = undefined;
    }
    return this.render(v);
  }
}

const cache = directive(CacheDirective);

const choose = (value, cases, defaultCase) => {
  for (const c of cases) {
    const caseValue = c[0];
    if (caseValue === value) {
      const fn = c[1];
      return fn();
    }
  }
  return defaultCase === null || defaultCase === void 0
    ? void 0
    : defaultCase();
};

class ClassMapDirective extends Directive {
  constructor(partInfo) {
    var _a;
    super(partInfo);
    if (
      partInfo.type !== PartType.ATTRIBUTE ||
      partInfo.name !== 'class' ||
      ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) >
        2
    ) {
      throw new Error(
        '`classMap()` can only be used in the `class` attribute ' +
          'and must be the only part in the attribute.'
      );
    }
  }
  render(classInfo) {
    return (
      ' ' +
      Object.keys(classInfo)
        .filter((key) => classInfo[key])
        .join(' ') +
      ' '
    );
  }
  update(part, [classInfo]) {
    var _a, _b;
    if (this._previousClasses === undefined) {
      this._previousClasses = new Set();
      if (part.strings !== undefined) {
        this._staticClasses = new Set(
          part.strings
            .join(' ')
            .split(/\s/)
            .filter((s) => s !== '')
        );
      }
      for (const name in classInfo) {
        if (
          classInfo[name] &&
          !((_a = this._staticClasses) === null || _a === void 0
            ? void 0
            : _a.has(name))
        ) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    this._previousClasses.forEach((name) => {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    });
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (
        value !== this._previousClasses.has(name) &&
        !((_b = this._staticClasses) === null || _b === void 0
          ? void 0
          : _b.has(name))
      ) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
}

const classMap = directive(ClassMapDirective);

const initialValue = {};

class GuardDirective extends Directive {
  constructor() {
    super(...arguments);
    this._previousValue = initialValue;
  }
  render(_value, f) {
    return f();
  }
  update(_part, [value, f]) {
    if (Array.isArray(value)) {
      if (
        Array.isArray(this._previousValue) &&
        this._previousValue.length === value.length &&
        value.every((v, i) => v === this._previousValue[i])
      ) {
        return noChange;
      }
    } else if (this._previousValue === value) {
      return noChange;
    }
    this._previousValue = Array.isArray(value) ? Array.from(value) : value;
    const r = this.render(value, f);
    return r;
  }
}

const guard = directive(GuardDirective);

const ifDefined = (value) =>
  value !== null && value !== void 0 ? value : nothing;

function* join(items, joiner) {
  const isFunction = typeof joiner === 'function';
  if (items !== undefined) {
    let i = -1;
    for (const value of items) {
      if (i > -1) {
        yield isFunction ? joiner(i) : joiner;
      }
      i++;
      yield value;
    }
  }
}

class Keyed extends Directive {
  constructor() {
    super(...arguments);
    this.key = nothing;
  }
  render(k, v) {
    this.key = k;
    return v;
  }
  update(part, [k, v]) {
    if (k !== this.key) {
      setCommittedValue(part);
      this.key = k;
    }
    return v;
  }
}

const keyed = directive(Keyed);

class LiveDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (
      !(
        partInfo.type === PartType.PROPERTY ||
        partInfo.type === PartType.ATTRIBUTE ||
        partInfo.type === PartType.BOOLEAN_ATTRIBUTE
      )
    ) {
      throw new Error(
        'The `live` directive is not allowed on child or event bindings'
      );
    }
    if (!isSingleExpression(partInfo)) {
      throw new Error('`live` bindings can only contain a single expression');
    }
  }
  render(value) {
    return value;
  }
  update(part, [value]) {
    if (value === noChange || value === nothing) {
      return value;
    }
    const element = part.element;
    const name = part.name;
    if (part.type === PartType.PROPERTY) {
      if (value === element[name]) {
        return noChange;
      }
    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
      if (!!value === element.hasAttribute(name)) {
        return noChange;
      }
    } else if (part.type === PartType.ATTRIBUTE) {
      if (element.getAttribute(name) === String(value)) {
        return noChange;
      }
    }
    setCommittedValue(part);
    return value;
  }
}

const live = directive(LiveDirective);

function* map(items, f) {
  if (items !== undefined) {
    let i = 0;
    for (const value of items) {
      yield f(value, i++);
    }
  }
}

function* range(startOrEnd, end, step = 1) {
  const start = end === undefined ? 0 : startOrEnd;
  end !== null && end !== void 0 ? end : (end = startOrEnd);
  for (let i = start; step > 0 ? i < end : end < i; i += step) {
    yield i;
  }
}

const createRef = () => new Ref();

class Ref {}

const lastElementForContextAndCallback = new WeakMap();

class RefDirective extends AsyncDirective {
  render(_ref) {
    return nothing;
  }
  update(part, [ref]) {
    var _a;
    const refChanged = ref !== this._ref;
    if (refChanged && this._ref !== undefined) {
      this._updateRefValue(undefined);
    }
    if (refChanged || this._lastElementForRef !== this._element) {
      this._ref = ref;
      this._context =
        (_a = part.options) === null || _a === void 0 ? void 0 : _a.host;
      this._updateRefValue((this._element = part.element));
    }
    return nothing;
  }
  _updateRefValue(element) {
    var _a;
    if (typeof this._ref === 'function') {
      const context =
        (_a = this._context) !== null && _a !== void 0 ? _a : globalThis;
      let lastElementForCallback =
        lastElementForContextAndCallback.get(context);
      if (lastElementForCallback === undefined) {
        lastElementForCallback = new WeakMap();
        lastElementForContextAndCallback.set(context, lastElementForCallback);
      }
      if (lastElementForCallback.get(this._ref) !== undefined) {
        this._ref.call(this._context, undefined);
      }
      lastElementForCallback.set(this._ref, element);
      if (element !== undefined) {
        this._ref.call(this._context, element);
      }
    } else {
      this._ref.value = element;
    }
  }
  get _lastElementForRef() {
    var _a, _b, _c;
    return typeof this._ref === 'function'
      ? (_b = lastElementForContextAndCallback.get(
          (_a = this._context) !== null && _a !== void 0 ? _a : globalThis
        )) === null || _b === void 0
        ? void 0
        : _b.get(this._ref)
      : (_c = this._ref) === null || _c === void 0
      ? void 0
      : _c.value;
  }
  disconnected() {
    if (this._lastElementForRef === this._element) {
      this._updateRefValue(undefined);
    }
  }
  reconnected() {
    this._updateRefValue(this._element);
  }
}

const ref = directive(RefDirective);

const generateMap = (list, start, end) => {
  const map = new Map();
  for (let i = start; i <= end; i++) {
    map.set(list[i], i);
  }
  return map;
};

class RepeatDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error('repeat() can only be used in text expressions');
    }
  }
  _getValuesAndKeys(items, keyFnOrTemplate, template) {
    let keyFn;
    if (template === undefined) {
      template = keyFnOrTemplate;
    } else if (keyFnOrTemplate !== undefined) {
      keyFn = keyFnOrTemplate;
    }
    const keys = [];
    const values = [];
    let index = 0;
    for (const item of items) {
      keys[index] = keyFn ? keyFn(item, index) : index;
      values[index] = template(item, index);
      index++;
    }
    return {
      values: values,
      keys: keys,
    };
  }
  render(items, keyFnOrTemplate, template) {
    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
  }
  update(containerPart, [items, keyFnOrTemplate, template]) {
    var _a;
    const oldParts = getCommittedValue(containerPart);
    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(
      items,
      keyFnOrTemplate,
      template
    );
    if (!Array.isArray(oldParts)) {
      this._itemKeys = newKeys;
      return newValues;
    }
    const oldKeys =
      (_a = this._itemKeys) !== null && _a !== void 0
        ? _a
        : (this._itemKeys = []);
    const newParts = [];
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(
          oldParts[oldHead],
          newValues[newHead]
        );
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(
          oldParts[oldTail],
          newValues[newTail]
        );
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(
          oldParts[oldHead],
          newValues[newTail]
        );
        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(
          oldParts[oldTail],
          newValues[newHead]
        );
        insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === undefined) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = insertPart(containerPart, oldParts[oldHead]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
            insertPart(containerPart, oldParts[oldHead], oldPart);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = insertPart(containerPart, newParts[newTail + 1]);
      setChildPartValue(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    this._itemKeys = newKeys;
    setCommittedValue(containerPart, newParts);
    return noChange;
  }
}

const repeat = directive(RepeatDirective);

const important = 'important';

const importantFlag = ' !' + important;

const flagTrim = 0 - importantFlag.length;

class StyleMapDirective extends Directive {
  constructor(partInfo) {
    var _a;
    super(partInfo);
    if (
      partInfo.type !== PartType.ATTRIBUTE ||
      partInfo.name !== 'style' ||
      ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) >
        2
    ) {
      throw new Error(
        'The `styleMap` directive must be used in the `style` attribute ' +
          'and must be the only part in the attribute.'
      );
    }
  }
  render(styleInfo) {
    return Object.keys(styleInfo).reduce((style, prop) => {
      const value = styleInfo[prop];
      if (value == null) {
        return style;
      }
      prop = prop.includes('-')
        ? prop
        : prop
            .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')
            .toLowerCase();
      return style + `${prop}:${value};`;
    }, '');
  }
  update(part, [styleInfo]) {
    const {style: style} = part.element;
    if (this._previousStyleProperties === undefined) {
      this._previousStyleProperties = new Set();
      for (const name in styleInfo) {
        this._previousStyleProperties.add(name);
      }
      return this.render(styleInfo);
    }
    this._previousStyleProperties.forEach((name) => {
      if (styleInfo[name] == null) {
        this._previousStyleProperties.delete(name);
        if (name.includes('-')) {
          style.removeProperty(name);
        } else {
          style[name] = '';
        }
      }
    });
    for (const name in styleInfo) {
      const value = styleInfo[name];
      if (value != null) {
        this._previousStyleProperties.add(name);
        const isImportant =
          typeof value === 'string' && value.endsWith(importantFlag);
        if (name.includes('-') || isImportant) {
          style.setProperty(
            name,
            isImportant ? value.slice(0, flagTrim) : value,
            isImportant ? important : ''
          );
        } else {
          style[name] = value;
        }
      }
    }
    return noChange;
  }
}

const styleMap = directive(StyleMapDirective);

class TemplateContentDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error('templateContent can only be used in child bindings');
    }
  }
  render(template) {
    if (this._previousTemplate === template) {
      return noChange;
    }
    this._previousTemplate = template;
    return document.importNode(template.content, true);
  }
}

const templateContent = directive(TemplateContentDirective);

const HTML_RESULT = 1;

class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(
        `${this.constructor.directiveName}() can only be used in child bindings`
      );
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = undefined;
      return (this._value = value);
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != 'string') {
      throw new Error(
        `${this.constructor.directiveName}() called with a non-string value`
      );
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return (this._templateResult = {
      ['_$litType$']: this.constructor.resultType,
      strings: strings,
      values: [],
    });
  }
}

UnsafeHTMLDirective.directiveName = 'unsafeHTML';

UnsafeHTMLDirective.resultType = HTML_RESULT;

const unsafeHTML = directive(UnsafeHTMLDirective);

const SVG_RESULT = 2;

class UnsafeSVGDirective extends UnsafeHTMLDirective {}

UnsafeSVGDirective.directiveName = 'unsafeSVG';

UnsafeSVGDirective.resultType = SVG_RESULT;

const unsafeSVG = directive(UnsafeSVGDirective);

const isPromise = (x) => !isPrimitive(x) && typeof x.then === 'function';

const _infinity = 1073741823;

class UntilDirective extends AsyncDirective {
  constructor() {
    super(...arguments);
    this.__lastRenderedIndex = _infinity;
    this.__values = [];
    this.__weakThis = new PseudoWeakRef(this);
    this.__pauser = new Pauser();
  }
  render(...args) {
    var _a;
    return (_a = args.find((x) => !isPromise(x))) !== null && _a !== void 0
      ? _a
      : noChange;
  }
  update(_part, args) {
    const previousValues = this.__values;
    let previousLength = previousValues.length;
    this.__values = args;
    const weakThis = this.__weakThis;
    const pauser = this.__pauser;
    if (!this.isConnected) {
      this.disconnected();
    }
    for (let i = 0; i < args.length; i++) {
      if (i > this.__lastRenderedIndex) {
        break;
      }
      const value = args[i];
      if (!isPromise(value)) {
        this.__lastRenderedIndex = i;
        return value;
      }
      if (i < previousLength && value === previousValues[i]) {
        continue;
      }
      this.__lastRenderedIndex = _infinity;
      previousLength = 0;
      Promise.resolve(value).then(async (result) => {
        while (pauser.get()) {
          await pauser.get();
        }
        const _this = weakThis.deref();
        if (_this !== undefined) {
          const index = _this.__values.indexOf(value);
          if (index > -1 && index < _this.__lastRenderedIndex) {
            _this.__lastRenderedIndex = index;
            _this.setValue(result);
          }
        }
      });
    }
    return noChange;
  }
  disconnected() {
    this.__weakThis.disconnect();
    this.__pauser.pause();
  }
  reconnected() {
    this.__weakThis.reconnect(this);
    this.__pauser.resume();
  }
}

const until = directive(UntilDirective);

function when(condition, trueCase, falseCase) {
  return condition
    ? trueCase()
    : falseCase === null || falseCase === void 0
    ? void 0
    : falseCase();
}

const brand = Symbol.for('');

const unwrapStaticValue = (value) => {
  if ((value === null || value === void 0 ? void 0 : value.r) !== brand) {
    return undefined;
  }
  return value === null || value === void 0 ? void 0 : value['_$litStatic$'];
};

const unsafeStatic = (value) => ({
  ['_$litStatic$']: value,
  r: brand,
});

const textFromStatic = (value) => {
  if (value['_$litStatic$'] !== undefined) {
    return value['_$litStatic$'];
  } else {
    throw new Error(
      `Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`
    );
  }
};

const literal = (strings, ...values) => ({
  ['_$litStatic$']: values.reduce(
    (acc, v, idx) => acc + textFromStatic(v) + strings[idx + 1],
    strings[0]
  ),
  r: brand,
});

const stringsCache = new Map();

const withStatic =
  (coreTag) =>
  (strings, ...values) => {
    const l = values.length;
    let staticValue;
    let dynamicValue;
    const staticStrings = [];
    const dynamicValues = [];
    let i = 0;
    let hasStatics = false;
    let s;
    while (i < l) {
      s = strings[i];
      while (
        i < l &&
        ((dynamicValue = values[i]),
        (staticValue = unwrapStaticValue(dynamicValue))) !== undefined
      ) {
        s += staticValue + strings[++i];
        hasStatics = true;
      }
      if (i !== l) {
        dynamicValues.push(dynamicValue);
      }
      staticStrings.push(s);
      i++;
    }
    if (i === l) {
      staticStrings.push(strings[l]);
    }
    if (hasStatics) {
      const key = staticStrings.join('$$lit$$');
      strings = stringsCache.get(key);
      if (strings === undefined) {
        staticStrings.raw = staticStrings;
        stringsCache.set(key, (strings = staticStrings));
      }
      values = dynamicValues;
    }
    return coreTag(strings, ...values);
  };

const html = withStatic(html$1);

const svg = withStatic(svg$1);

if (!window.litDisableBundleWarning) {
  console.warn(
    'Lit has been loaded from a bundle that combines all core features into ' +
      'a single file. To reduce transfer size and parsing cost, consider ' +
      'using the `lit` npm package directly in your project.'
  );
}

export {
  AsyncDirective,
  AsyncReplaceDirective,
  CSSResult,
  Directive,
  LitElement,
  PartType,
  ReactiveElement,
  TemplateResultType,
  UnsafeHTMLDirective,
  UntilDirective,
  UpdatingElement,
  _$LE,
  _$LH,
  adoptStyles,
  asyncAppend,
  asyncReplace,
  cache,
  choose,
  classMap,
  clearPart,
  createRef,
  css,
  defaultConverter,
  directive,
  getCommittedValue,
  getCompatibleStyle,
  getDirectiveClass,
  guard,
  html$1 as html,
  ifDefined,
  insertPart,
  isDirectiveResult,
  isPrimitive,
  isServer,
  isSingleExpression,
  isTemplateResult,
  join,
  keyed,
  literal,
  live,
  map,
  noChange,
  notEqual,
  nothing,
  range,
  ref,
  removePart,
  render,
  repeat,
  setChildPartValue,
  setCommittedValue,
  html as staticHtml,
  svg as staticSvg,
  styleMap,
  supportsAdoptingStyleSheets,
  svg$1 as svg,
  templateContent,
  unsafeCSS,
  unsafeHTML,
  unsafeSVG,
  unsafeStatic,
  until,
  when,
  withStatic,
};
//# sourceMappingURL=lit-all.es.min.js.map
