import 'core-js/modules/es.global-this.js';
import 'core-js/modules/es.array.flat.js';
import 'core-js/modules/es.array.unscopables.flat.js';
import 'core-js/modules/es.array.unshift.js';
import 'core-js/modules/es.string.trim.js';
const t = window,
  e =
    t.ShadowRoot &&
    (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype,
  i = Symbol(),
  s = new WeakMap();
class n {
  constructor(t, e, s) {
    if (((this._$cssResult$ = !0), s !== i))
      throw new Error(
        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'
      );
    (this.cssText = t), (this._strings = e);
  }
  get styleSheet() {
    let t = this._styleSheet;
    const i = this._strings;
    if (e && void 0 === t) {
      const e = void 0 !== i && 1 === i.length;
      e && (t = s.get(i)),
        void 0 === t &&
          ((this._styleSheet = t = new CSSStyleSheet()).replaceSync(
            this.cssText
          ),
          e && s.set(i, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}
const r = (t) => new n('string' == typeof t ? t : String(t), void 0, i),
  o = function (t) {
    for (
      var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), r = 1;
      r < e;
      r++
    )
      s[r - 1] = arguments[r];
    const o =
      1 === t.length
        ? t[0]
        : s.reduce(
            (e, i, s) =>
              e +
              ((t) => {
                if (!0 === t._$cssResult$) return t.cssText;
                if ('number' == typeof t) return t;
                throw new Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    ''.concat(
                      t,
                      ". Use 'unsafeCSS' to pass non-literal values, but take care "
                    ) +
                    'to ensure page security.'
                );
              })(i) +
              t[s + 1],
            t[0]
          );
    return new n(o, t, i);
  },
  l = (i, s) => {
    e
      ? (i.adoptedStyleSheets = s.map((t) =>
          t instanceof CSSStyleSheet ? t : t.styleSheet
        ))
      : s.forEach((e) => {
          const s = document.createElement('style'),
            n = t.litNonce;
          void 0 !== n && s.setAttribute('nonce', n),
            (s.textContent = e.cssText),
            i.appendChild(s);
        });
  },
  a = e
    ? (t) => t
    : (t) =>
        t instanceof CSSStyleSheet
          ? ((t) => {
              let e = '';
              for (const i of t.cssRules) e += i.cssText;
              return r(e);
            })(t)
          : t;
var c;
const d = window,
  h = d.trustedTypes,
  u = h ? h.emptyScript : '',
  _ = d.reactiveElementPolyfillSupport,
  p = {
    toAttribute(t, e) {
      switch (e) {
        case Boolean:
          t = t ? u : null;
          break;
        case Object:
        case Array:
          t = null == t ? t : JSON.stringify(t);
      }
      return t;
    },
    fromAttribute(t, e) {
      let i = t;
      switch (e) {
        case Boolean:
          i = null !== t;
          break;
        case Number:
          i = null === t ? null : Number(t);
          break;
        case Object:
        case Array:
          try {
            i = JSON.parse(t);
          } catch (t) {
            i = null;
          }
      }
      return i;
    },
  },
  v = (t, e) => e !== t && (e == e || t == t),
  f = {attribute: !0, type: String, converter: p, reflect: !1, hasChanged: v},
  m = 'finalized';
class y extends HTMLElement {
  constructor() {
    super(),
      (this.__instanceProperties = new Map()),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this.__reflectingProperty = null),
      this._initialize();
  }
  static addInitializer(t) {
    var e;
    this.finalize(),
      (null !== (e = this._initializers) && void 0 !== e
        ? e
        : (this._initializers = [])
      ).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return (
      this.elementProperties.forEach((e, i) => {
        const s = this.__attributeNameForProperty(i, e);
        void 0 !== s && (this.__attributeToPropertyMap.set(s, i), t.push(s));
      }),
      t
    );
  }
  static createProperty(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f;
    if (
      (e.state && (e.attribute = !1),
      this.finalize(),
      this.elementProperties.set(t, e),
      !e.noAccessor && !this.prototype.hasOwnProperty(t))
    ) {
      const i = 'symbol' == typeof t ? Symbol() : '__'.concat(t),
        s = this.getPropertyDescriptor(t, i, e);
      void 0 !== s && Object.defineProperty(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return {
      get() {
        return this[e];
      },
      set(s) {
        const n = this[t];
        (this[e] = s), this.requestUpdate(t, n, i);
      },
      configurable: !0,
      enumerable: !0,
    };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || f;
  }
  static finalize() {
    if (this.hasOwnProperty(m)) return !1;
    this[m] = !0;
    const t = Object.getPrototypeOf(this);
    if (
      (t.finalize(),
      void 0 !== t._initializers && (this._initializers = [...t._initializers]),
      (this.elementProperties = new Map(t.elementProperties)),
      (this.__attributeToPropertyMap = new Map()),
      this.hasOwnProperty('properties'))
    ) {
      const t = this.properties,
        e = [
          ...Object.getOwnPropertyNames(t),
          ...Object.getOwnPropertySymbols(t),
        ];
      for (const i of e) this.createProperty(i, t[i]);
    }
    return (this.elementStyles = this.finalizeStyles(this.styles)), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const t of i) e.unshift(a(t));
    } else void 0 !== t && e.push(a(t));
    return e;
  }
  static __attributeNameForProperty(t, e) {
    const i = e.attribute;
    return !1 === i
      ? void 0
      : 'string' == typeof i
      ? i
      : 'string' == typeof t
      ? t.toLowerCase()
      : void 0;
  }
  _initialize() {
    var t;
    (this.__updatePromise = new Promise((t) => (this.enableUpdating = t))),
      (this._$changedProperties = new Map()),
      this.__saveInstanceProperties(),
      this.requestUpdate(),
      null === (t = this.constructor._initializers) ||
        void 0 === t ||
        t.forEach((t) => t(this));
  }
  addController(t) {
    var e, i;
    (null !== (e = this.__controllers) && void 0 !== e
      ? e
      : (this.__controllers = [])
    ).push(t),
      void 0 !== this.renderRoot &&
        this.isConnected &&
        (null === (i = t.hostConnected) || void 0 === i || i.call(t));
  }
  removeController(t) {
    var e;
    null === (e = this.__controllers) ||
      void 0 === e ||
      e.splice(this.__controllers.indexOf(t) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) &&
        (this.__instanceProperties.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e =
      null !== (t = this.shadowRoot) && void 0 !== t
        ? t
        : this.attachShadow(this.constructor.shadowRootOptions);
    return l(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      null === (t = this.__controllers) ||
        void 0 === t ||
        t.forEach((t) => {
          var e;
          return null === (e = t.hostConnected) || void 0 === e
            ? void 0
            : e.call(t);
        });
  }
  enableUpdating(t) {}
  disconnectedCallback() {
    var t;
    null === (t = this.__controllers) ||
      void 0 === t ||
      t.forEach((t) => {
        var e;
        return null === (e = t.hostDisconnected) || void 0 === e
          ? void 0
          : e.call(t);
      });
  }
  attributeChangedCallback(t, e, i) {
    this._$attributeToProperty(t, i);
  }
  __propertyToAttribute(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : f;
    var s;
    const n = this.constructor.__attributeNameForProperty(t, i);
    if (void 0 !== n && !0 === i.reflect) {
      const r = (
        void 0 !==
        (null === (s = i.converter) || void 0 === s ? void 0 : s.toAttribute)
          ? i.converter
          : p
      ).toAttribute(e, i.type);
      (this.__reflectingProperty = t),
        null == r ? this.removeAttribute(n) : this.setAttribute(n, r),
        (this.__reflectingProperty = null);
    }
  }
  _$attributeToProperty(t, e) {
    var i;
    const s = this.constructor,
      n = s.__attributeToPropertyMap.get(t);
    if (void 0 !== n && this.__reflectingProperty !== n) {
      const t = s.getPropertyOptions(n),
        r =
          'function' == typeof t.converter
            ? {fromAttribute: t.converter}
            : void 0 !==
              (null === (i = t.converter) || void 0 === i
                ? void 0
                : i.fromAttribute)
            ? t.converter
            : p;
      (this.__reflectingProperty = n),
        (this[n] = r.fromAttribute(e, t.type)),
        (this.__reflectingProperty = null);
    }
  }
  requestUpdate(t, e, i) {
    let s = !0;
    if (void 0 !== t) {
      ((i = i || this.constructor.getPropertyOptions(t)).hasChanged || v)(
        this[t],
        e
      )
        ? (this._$changedProperties.has(t) ||
            this._$changedProperties.set(t, e),
          !0 === i.reflect &&
            this.__reflectingProperty !== t &&
            (void 0 === this.__reflectingProperties &&
              (this.__reflectingProperties = new Map()),
            this.__reflectingProperties.set(t, i)))
        : (s = !1);
    }
    !this.isUpdatePending &&
      s &&
      (this.__updatePromise = this.__enqueueUpdate());
  }
  async __enqueueUpdate() {
    this.isUpdatePending = !0;
    try {
      await this.__updatePromise;
    } catch (t) {
      Promise.reject(t);
    }
    const t = this.scheduleUpdate();
    return null != t && (await t), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated,
      this.__instanceProperties &&
        (this.__instanceProperties.forEach((t, e) => (this[e] = t)),
        (this.__instanceProperties = void 0));
    let e = !1;
    const i = this._$changedProperties;
    try {
      (e = this.shouldUpdate(i)),
        e
          ? (this.willUpdate(i),
            null === (t = this.__controllers) ||
              void 0 === t ||
              t.forEach((t) => {
                var e;
                return null === (e = t.hostUpdate) || void 0 === e
                  ? void 0
                  : e.call(t);
              }),
            this.update(i))
          : this.__markUpdated();
    } catch (t) {
      throw ((e = !1), this.__markUpdated(), t);
    }
    e && this._$didUpdate(i);
  }
  willUpdate(t) {}
  _$didUpdate(t) {
    var e;
    null === (e = this.__controllers) ||
      void 0 === e ||
      e.forEach((t) => {
        var e;
        return null === (e = t.hostUpdated) || void 0 === e
          ? void 0
          : e.call(t);
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(t)),
      this.updated(t);
  }
  __markUpdated() {
    (this._$changedProperties = new Map()), (this.isUpdatePending = !1);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    void 0 !== this.__reflectingProperties &&
      (this.__reflectingProperties.forEach((t, e) =>
        this.__propertyToAttribute(e, this[e], t)
      ),
      (this.__reflectingProperties = void 0)),
      this.__markUpdated();
  }
  updated(t) {}
  firstUpdated(t) {}
}
var g;
(y[m] = !0),
  (y.elementProperties = new Map()),
  (y.elementStyles = []),
  (y.shadowRootOptions = {mode: 'open'}),
  null == _ || _({ReactiveElement: y}),
  (null !== (c = d.reactiveElementVersions) && void 0 !== c
    ? c
    : (d.reactiveElementVersions = [])
  ).push('1.6.1');
const $ = window,
  b = $.trustedTypes,
  w = b ? b.createPolicy('lit-html', {createHTML: (t) => t}) : void 0,
  C = '$lit$',
  P = 'lit$'.concat(String(Math.random()).slice(9), '$'),
  S = '?' + P,
  T = '<'.concat(S, '>'),
  x = document,
  V = () => x.createComment(''),
  E = (t) => null === t || ('object' != typeof t && 'function' != typeof t),
  A = Array.isArray,
  N = (t) =>
    A(t) || 'function' == typeof (null == t ? void 0 : t[Symbol.iterator]),
  R = '[ \t\n\f\r]',
  U = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  k = /-->/g,
  O = />/g,
  I = new RegExp(
    '>|'
      .concat(R, '(?:(')
      .concat('[^\\s"\'>=/]', '+)(')
      .concat(R, '*=')
      .concat(R, '*(?:')
      .concat('[^ \t\n\f\r"\'`<>=]', '|("|\')|))|$)'),
    'g'
  ),
  j = /'/g,
  M = /"/g,
  z = /^(?:script|style|textarea|title)$/i,
  L = (t) =>
    function (e) {
      for (
        var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), n = 1;
        n < i;
        n++
      )
        s[n - 1] = arguments[n];
      return {_$litType$: t, strings: e, values: s};
    },
  B = L(1),
  D = L(2),
  H = Symbol.for('lit-noChange'),
  W = Symbol.for('lit-nothing'),
  F = new WeakMap(),
  K = x.createTreeWalker(x, 129, null, !1),
  q = (t, e) => {
    const i = t.length - 1,
      s = [];
    let n,
      r = 2 === e ? '<svg>' : '',
      o = U;
    for (let e = 0; e < i; e++) {
      const i = t[e];
      let l,
        a,
        c = -1,
        d = 0;
      for (; d < i.length && ((o.lastIndex = d), (a = o.exec(i)), null !== a); )
        (d = o.lastIndex),
          o === U
            ? '!--' === a[1]
              ? (o = k)
              : void 0 !== a[1]
              ? (o = O)
              : void 0 !== a[2]
              ? (z.test(a[2]) && (n = new RegExp('</'.concat(a[2]), 'g')),
                (o = I))
              : void 0 !== a[3] && (o = I)
            : o === I
            ? '>' === a[0]
              ? ((o = null != n ? n : U), (c = -1))
              : void 0 === a[1]
              ? (c = -2)
              : ((c = o.lastIndex - a[2].length),
                (l = a[1]),
                (o = void 0 === a[3] ? I : '"' === a[3] ? M : j))
            : o === M || o === j
            ? (o = I)
            : o === k || o === O
            ? (o = U)
            : ((o = I), (n = void 0));
      const h = o === I && t[e + 1].startsWith('/>') ? ' ' : '';
      r +=
        o === U
          ? i + T
          : c >= 0
          ? (s.push(l), i.slice(0, c) + C + i.slice(c) + P + h)
          : i + P + (-2 === c ? (s.push(void 0), e) : h);
    }
    const l = r + (t[i] || '<?>') + (2 === e ? '</svg>' : '');
    if (!Array.isArray(t) || !t.hasOwnProperty('raw')) {
      throw new Error('invalid template strings array');
    }
    return [void 0 !== w ? w.createHTML(l) : l, s];
  };
class Y {
  constructor(t, e) {
    let i,
      {strings: s, _$litType$: n} = t;
    this.parts = [];
    let r = 0,
      o = 0;
    const l = s.length - 1,
      a = this.parts,
      [c, d] = q(s, n);
    if (
      ((this.el = Y.createElement(c, e)),
      (K.currentNode = this.el.content),
      2 === n)
    ) {
      const t = this.el.content,
        e = t.firstChild;
      e.remove(), t.append(...e.childNodes);
    }
    for (; null !== (i = K.nextNode()) && a.length < l; ) {
      if (1 === i.nodeType) {
        if (i.hasAttributes()) {
          const t = [];
          for (const e of i.getAttributeNames())
            if (e.endsWith(C) || e.startsWith(P)) {
              const s = d[o++];
              if ((t.push(e), void 0 !== s)) {
                const t = i.getAttribute(s.toLowerCase() + C).split(P),
                  e = /([.?@])?(.*)/.exec(s);
                a.push({
                  type: 1,
                  index: r,
                  name: e[2],
                  strings: t,
                  ctor:
                    '.' === e[1]
                      ? X
                      : '?' === e[1]
                      ? et
                      : '@' === e[1]
                      ? it
                      : Q,
                });
              } else a.push({type: 6, index: r});
            }
          for (const e of t) i.removeAttribute(e);
        }
        if (z.test(i.tagName)) {
          const t = i.textContent.split(P),
            e = t.length - 1;
          if (e > 0) {
            i.textContent = b ? b.emptyScript : '';
            for (let s = 0; s < e; s++)
              i.append(t[s], V()), K.nextNode(), a.push({type: 2, index: ++r});
            i.append(t[e], V());
          }
        }
      } else if (8 === i.nodeType) {
        if (i.data === S) a.push({type: 2, index: r});
        else {
          let t = -1;
          for (; -1 !== (t = i.data.indexOf(P, t + 1)); )
            a.push({type: 7, index: r}), (t += P.length - 1);
        }
      }
      r++;
    }
  }
  static createElement(t, e) {
    const i = x.createElement('template');
    return (i.innerHTML = t), i;
  }
}
function Z(t, e) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
    s = arguments.length > 3 ? arguments[3] : void 0;
  var n, r, o, l;
  if (e === H) return e;
  let a =
    void 0 !== s
      ? null === (n = i.__directives) || void 0 === n
        ? void 0
        : n[s]
      : i.__directive;
  const c = E(e) ? void 0 : e._$litDirective$;
  return (
    (null == a ? void 0 : a.constructor) !== c &&
      (null ===
        (r = null == a ? void 0 : a._$notifyDirectiveConnectionChanged) ||
        void 0 === r ||
        r.call(a, !1),
      void 0 === c ? (a = void 0) : ((a = new c(t)), a._$initialize(t, i, s)),
      void 0 !== s
        ? ((null !== (o = (l = i).__directives) && void 0 !== o
            ? o
            : (l.__directives = []))[s] = a)
        : (i.__directive = a)),
    void 0 !== a && (e = Z(t, a._$resolve(t, e.values), a, s)),
    e
  );
}
class G {
  constructor(t, e) {
    (this._$parts = []),
      (this._$disconnectableChildren = void 0),
      (this._$template = t),
      (this._$parent = e);
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(t) {
    var e;
    const {
        el: {content: i},
        parts: s,
      } = this._$template,
      n = (
        null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e
          ? e
          : x
      ).importNode(i, !0);
    K.currentNode = n;
    let r = K.nextNode(),
      o = 0,
      l = 0,
      a = s[0];
    for (; void 0 !== a; ) {
      if (o === a.index) {
        let e;
        2 === a.type
          ? (e = new J(r, r.nextSibling, this, t))
          : 1 === a.type
          ? (e = new a.ctor(r, a.name, a.strings, this, t))
          : 6 === a.type && (e = new st(r, this, t)),
          this._$parts.push(e),
          (a = s[++l]);
      }
      o !== (null == a ? void 0 : a.index) && ((r = K.nextNode()), o++);
    }
    return (K.currentNode = x), n;
  }
  _update(t) {
    let e = 0;
    for (const i of this._$parts)
      void 0 !== i &&
        (void 0 !== i.strings
          ? (i._$setValue(t, i, e), (e += i.strings.length - 2))
          : i._$setValue(t[e])),
        e++;
  }
}
class J {
  constructor(t, e, i, s) {
    var n;
    (this.type = 2),
      (this._$committedValue = W),
      (this._$disconnectableChildren = void 0),
      (this._$startNode = t),
      (this._$endNode = e),
      (this._$parent = i),
      (this.options = s),
      (this.__isConnected =
        null === (n = null == s ? void 0 : s.isConnected) || void 0 === n || n);
  }
  get _$isConnected() {
    var t, e;
    return null !==
      (e =
        null === (t = this._$parent) || void 0 === t
          ? void 0
          : t._$isConnected) && void 0 !== e
      ? e
      : this.__isConnected;
  }
  get parentNode() {
    let t = this._$startNode.parentNode;
    const e = this._$parent;
    return (
      void 0 !== e &&
        11 === (null == t ? void 0 : t.nodeType) &&
        (t = e.parentNode),
      t
    );
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(t) {
    (t = Z(
      this,
      t,
      arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this
    )),
      E(t)
        ? t === W || null == t || '' === t
          ? (this._$committedValue !== W && this._$clear(),
            (this._$committedValue = W))
          : t !== this._$committedValue && t !== H && this._commitText(t)
        : void 0 !== t._$litType$
        ? this._commitTemplateResult(t)
        : void 0 !== t.nodeType
        ? this._commitNode(t)
        : N(t)
        ? this._commitIterable(t)
        : this._commitText(t);
  }
  _insert(t) {
    return this._$startNode.parentNode.insertBefore(t, this._$endNode);
  }
  _commitNode(t) {
    this._$committedValue !== t &&
      (this._$clear(), (this._$committedValue = this._insert(t)));
  }
  _commitText(t) {
    if (this._$committedValue !== W && E(this._$committedValue)) {
      this._$startNode.nextSibling.data = t;
    } else this._commitNode(x.createTextNode(t));
    this._$committedValue = t;
  }
  _commitTemplateResult(t) {
    var e;
    const {values: i, _$litType$: s} = t,
      n =
        'number' == typeof s
          ? this._$getTemplate(t)
          : (void 0 === s.el && (s.el = Y.createElement(s.h, this.options)), s);
    if (
      (null === (e = this._$committedValue) || void 0 === e
        ? void 0
        : e._$template) === n
    )
      this._$committedValue._update(i);
    else {
      const t = new G(n, this),
        e = t._clone(this.options);
      t._update(i), this._commitNode(e), (this._$committedValue = t);
    }
  }
  _$getTemplate(t) {
    let e = F.get(t.strings);
    return void 0 === e && F.set(t.strings, (e = new Y(t))), e;
  }
  _commitIterable(t) {
    A(this._$committedValue) || ((this._$committedValue = []), this._$clear());
    const e = this._$committedValue;
    let i,
      s = 0;
    for (const n of t)
      s === e.length
        ? e.push(
            (i = new J(
              this._insert(V()),
              this._insert(V()),
              this,
              this.options
            ))
          )
        : (i = e[s]),
        i._$setValue(n),
        s++;
    s < e.length &&
      (this._$clear(i && i._$endNode.nextSibling, s), (e.length = s));
  }
  _$clear() {
    let t =
        arguments.length > 0 && void 0 !== arguments[0]
          ? arguments[0]
          : this._$startNode.nextSibling,
      e = arguments.length > 1 ? arguments[1] : void 0;
    var i;
    for (
      null === (i = this._$notifyConnectionChanged) ||
      void 0 === i ||
      i.call(this, !1, !0, e);
      t && t !== this._$endNode;

    ) {
      const e = t.nextSibling;
      t.remove(), (t = e);
    }
  }
  setConnected(t) {
    var e;
    void 0 === this._$parent &&
      ((this.__isConnected = t),
      null === (e = this._$notifyConnectionChanged) ||
        void 0 === e ||
        e.call(this, t));
  }
}
class Q {
  constructor(t, e, i, s, n) {
    (this.type = 1),
      (this._$committedValue = W),
      (this._$disconnectableChildren = void 0),
      (this.element = t),
      (this.name = e),
      (this._$parent = s),
      (this.options = n),
      i.length > 2 || '' !== i[0] || '' !== i[1]
        ? ((this._$committedValue = new Array(i.length - 1).fill(new String())),
          (this.strings = i))
        : (this._$committedValue = W);
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(t) {
    let e =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this,
      i = arguments.length > 2 ? arguments[2] : void 0,
      s = arguments.length > 3 ? arguments[3] : void 0;
    const n = this.strings;
    let r = !1;
    if (void 0 === n)
      (t = Z(this, t, e, 0)),
        (r = !E(t) || (t !== this._$committedValue && t !== H)),
        r && (this._$committedValue = t);
    else {
      const s = t;
      let o, l;
      for (t = n[0], o = 0; o < n.length - 1; o++)
        (l = Z(this, s[i + o], e, o)),
          l === H && (l = this._$committedValue[o]),
          r || (r = !E(l) || l !== this._$committedValue[o]),
          l === W ? (t = W) : t !== W && (t += (null != l ? l : '') + n[o + 1]),
          (this._$committedValue[o] = l);
    }
    r && !s && this._commitValue(t);
  }
  _commitValue(t) {
    t === W
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, null != t ? t : '');
  }
}
class X extends Q {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  _commitValue(t) {
    this.element[this.name] = t === W ? void 0 : t;
  }
}
const tt = b ? b.emptyScript : '';
class et extends Q {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  _commitValue(t) {
    t && t !== W
      ? this.element.setAttribute(this.name, tt)
      : this.element.removeAttribute(this.name);
  }
}
class it extends Q {
  constructor(t, e, i, s, n) {
    super(t, e, i, s, n), (this.type = 5);
  }
  _$setValue(t) {
    var e;
    if (
      (t =
        null !==
          (e = Z(
            this,
            t,
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : this,
            0
          )) && void 0 !== e
          ? e
          : W) === H
    )
      return;
    const i = this._$committedValue,
      s =
        (t === W && i !== W) ||
        t.capture !== i.capture ||
        t.once !== i.once ||
        t.passive !== i.passive,
      n = t !== W && (i === W || s);
    s && this.element.removeEventListener(this.name, this, i),
      n && this.element.addEventListener(this.name, this, t),
      (this._$committedValue = t);
  }
  handleEvent(t) {
    var e, i;
    'function' == typeof this._$committedValue
      ? this._$committedValue.call(
          null !==
            (i =
              null === (e = this.options) || void 0 === e ? void 0 : e.host) &&
            void 0 !== i
            ? i
            : this.element,
          t
        )
      : this._$committedValue.handleEvent(t);
  }
}
class st {
  constructor(t, e, i) {
    (this.element = t),
      (this.type = 6),
      (this._$disconnectableChildren = void 0),
      (this._$parent = e),
      (this.options = i);
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(t) {
    Z(this, t);
  }
}
const nt = {
    _boundAttributeSuffix: C,
    _marker: P,
    _markerMatch: S,
    _HTML_RESULT: 1,
    _getTemplateHtml: q,
    _TemplateInstance: G,
    _isIterable: N,
    _resolveDirective: Z,
    _ChildPart: J,
    _AttributePart: Q,
    _BooleanAttributePart: et,
    _EventPart: it,
    _PropertyPart: X,
    _ElementPart: st,
  },
  rt = $.litHtmlPolyfillSupport;
null == rt || rt(Y, J),
  (null !== (g = $.litHtmlVersions) && void 0 !== g
    ? g
    : ($.litHtmlVersions = [])
  ).push('2.7.3');
const ot = (t, e, i) => {
  var s, n;
  const r =
    null !== (s = null == i ? void 0 : i.renderBefore) && void 0 !== s ? s : e;
  let o = r._$litPart$;
  if (void 0 === o) {
    const t =
      null !== (n = null == i ? void 0 : i.renderBefore) && void 0 !== n
        ? n
        : null;
    r._$litPart$ = o = new J(
      e.insertBefore(V(), t),
      t,
      void 0,
      null != i ? i : {}
    );
  }
  return o._$setValue(t), o;
};
var lt, at;
const ct = y;
class dt extends y {
  constructor() {
    super(...arguments),
      (this.renderOptions = {host: this}),
      (this.__childPart = void 0);
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (
      (null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t) ||
        (e.renderBefore = i.firstChild),
      i
    );
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(t),
      (this.__childPart = ot(e, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var t;
    super.connectedCallback(),
      null === (t = this.__childPart) || void 0 === t || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(),
      null === (t = this.__childPart) || void 0 === t || t.setConnected(!1);
  }
  render() {
    return H;
  }
}
(dt.finalized = !0),
  (dt._$litElement$ = !0),
  null === (lt = globalThis.litElementHydrateSupport) ||
    void 0 === lt ||
    lt.call(globalThis, {LitElement: dt});
const ht = globalThis.litElementPolyfillSupport;
null == ht || ht({LitElement: dt});
const ut = {
  _$attributeToProperty: (t, e, i) => {
    t._$attributeToProperty(e, i);
  },
  _$changedProperties: (t) => t._$changedProperties,
};
(null !== (at = globalThis.litElementVersions) && void 0 !== at
  ? at
  : (globalThis.litElementVersions = [])
).push('3.3.2');
const _t = !1,
  {_ChildPart: pt} = nt,
  vt = (t) => null === t || ('object' != typeof t && 'function' != typeof t),
  ft = {HTML: 1, SVG: 2},
  mt = (t, e) =>
    void 0 === e
      ? void 0 !== (null == t ? void 0 : t._$litType$)
      : (null == t ? void 0 : t._$litType$) === e,
  yt = (t) => void 0 !== (null == t ? void 0 : t._$litDirective$),
  gt = (t) => (null == t ? void 0 : t._$litDirective$),
  $t = (t) => void 0 === t.strings,
  bt = () => document.createComment(''),
  wt = (t, e, i) => {
    var s;
    const n = t._$startNode.parentNode,
      r = void 0 === e ? t._$endNode : e._$startNode;
    if (void 0 === i) {
      const e = n.insertBefore(bt(), r),
        s = n.insertBefore(bt(), r);
      i = new pt(e, s, t, t.options);
    } else {
      const e = i._$endNode.nextSibling,
        o = i._$parent,
        l = o !== t;
      if (l) {
        let e;
        null === (s = i._$reparentDisconnectables) ||
          void 0 === s ||
          s.call(i, t),
          (i._$parent = t),
          void 0 !== i._$notifyConnectionChanged &&
            (e = t._$isConnected) !== o._$isConnected &&
            i._$notifyConnectionChanged(e);
      }
      if (e !== r || l) {
        let t = i._$startNode;
        for (; t !== e; ) {
          const e = t.nextSibling;
          n.insertBefore(t, r), (t = e);
        }
      }
    }
    return i;
  },
  Ct = function (t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t;
    return t._$setValue(e, i), t;
  },
  Pt = {},
  St = function (t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Pt;
    return (t._$committedValue = e);
  },
  Tt = (t) => t._$committedValue,
  xt = (t) => {
    var e;
    null === (e = t._$notifyConnectionChanged) ||
      void 0 === e ||
      e.call(t, !1, !0);
    let i = t._$startNode;
    const s = t._$endNode.nextSibling;
    for (; i !== s; ) {
      const t = i.nextSibling;
      i.remove(), (i = t);
    }
  },
  Vt = (t) => {
    t._$clear();
  },
  Et = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6,
  },
  At = (t) =>
    function () {
      for (var e = arguments.length, i = new Array(e), s = 0; s < e; s++)
        i[s] = arguments[s];
      return {_$litDirective$: t, values: i};
    };
class Nt {
  constructor(t) {}
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$initialize(t, e, i) {
    (this.__part = t), (this._$parent = e), (this.__attributeIndex = i);
  }
  _$resolve(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
}
const Rt = (t, e) => {
    var i, s;
    const n = t._$disconnectableChildren;
    if (void 0 === n) return !1;
    for (const t of n)
      null === (s = (i = t)._$notifyDirectiveConnectionChanged) ||
        void 0 === s ||
        s.call(i, e, !1),
        Rt(t, e);
    return !0;
  },
  Ut = (t) => {
    let e, i;
    do {
      if (void 0 === (e = t._$parent)) break;
      (i = e._$disconnectableChildren), i.delete(t), (t = e);
    } while (0 === (null == i ? void 0 : i.size));
  },
  kt = (t) => {
    for (let e; (e = t._$parent); t = e) {
      let i = e._$disconnectableChildren;
      if (void 0 === i) e._$disconnectableChildren = i = new Set();
      else if (i.has(t)) break;
      i.add(t), jt(e);
    }
  };
function Ot(t) {
  void 0 !== this._$disconnectableChildren
    ? (Ut(this), (this._$parent = t), kt(this))
    : (this._$parent = t);
}
function It(t) {
  let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
  const s = this._$committedValue,
    n = this._$disconnectableChildren;
  if (void 0 !== n && 0 !== n.size)
    if (e)
      if (Array.isArray(s))
        for (let t = i; t < s.length; t++) Rt(s[t], !1), Ut(s[t]);
      else null != s && (Rt(s, !1), Ut(s));
    else Rt(this, t);
}
const jt = (t) => {
  var e, i, s, n;
  t.type == Et.CHILD &&
    ((null !== (e = (s = t)._$notifyConnectionChanged) && void 0 !== e) ||
      (s._$notifyConnectionChanged = It),
    (null !== (i = (n = t)._$reparentDisconnectables) && void 0 !== i) ||
      (n._$reparentDisconnectables = Ot));
};
class Mt extends Nt {
  constructor() {
    super(...arguments), (this._$disconnectableChildren = void 0);
  }
  _$initialize(t, e, i) {
    super._$initialize(t, e, i), kt(this), (this.isConnected = t._$isConnected);
  }
  _$notifyDirectiveConnectionChanged(t) {
    let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var i, s;
    t !== this.isConnected &&
      ((this.isConnected = t),
      t
        ? null === (i = this.reconnected) || void 0 === i || i.call(this)
        : null === (s = this.disconnected) || void 0 === s || s.call(this)),
      e && (Rt(this, t), Ut(this));
  }
  setValue(t) {
    if ($t(this.__part)) this.__part._$setValue(t, this);
    else {
      const e = [...this.__part._$committedValue];
      (e[this.__attributeIndex] = t), this.__part._$setValue(e, this, 0);
    }
  }
  disconnected() {}
  reconnected() {}
}
function zt(t) {
  function e(t) {
    if (Object(t) !== t)
      return Promise.reject(new TypeError(t + ' is not an object.'));
    var e = t.done;
    return Promise.resolve(t.value).then(function (t) {
      return {value: t, done: e};
    });
  }
  return (
    (zt = function (t) {
      (this.s = t), (this.n = t.next);
    }),
    (zt.prototype = {
      s: null,
      n: null,
      next: function () {
        return e(this.n.apply(this.s, arguments));
      },
      return: function (t) {
        var i = this.s.return;
        return void 0 === i
          ? Promise.resolve({value: t, done: !0})
          : e(i.apply(this.s, arguments));
      },
      throw: function (t) {
        var i = this.s.return;
        return void 0 === i ? Promise.reject(t) : e(i.apply(this.s, arguments));
      },
    }),
    new zt(t)
  );
}
const Lt = async (t, e) => {
  var i,
    s = !1,
    n = !1;
  try {
    for (
      var r,
        o = (function (t) {
          var e,
            i,
            s,
            n = 2;
          for (
            'undefined' != typeof Symbol &&
            ((i = Symbol.asyncIterator), (s = Symbol.iterator));
            n--;

          ) {
            if (i && null != (e = t[i])) return e.call(t);
            if (s && null != (e = t[s])) return new zt(e.call(t));
            (i = '@@asyncIterator'), (s = '@@iterator');
          }
          throw new TypeError('Object is not async iterable');
        })(t);
      (s = !(r = await o.next()).done);
      s = !1
    ) {
      const t = r.value;
      if (!1 === (await e(t))) return;
    }
  } catch (t) {
    (n = !0), (i = t);
  } finally {
    try {
      s && null != o.return && (await o.return());
    } finally {
      if (n) throw i;
    }
  }
};
class Bt {
  constructor(t) {
    this._ref = t;
  }
  disconnect() {
    this._ref = void 0;
  }
  reconnect(t) {
    this._ref = t;
  }
  deref() {
    return this._ref;
  }
}
class Dt {
  constructor() {
    (this._promise = void 0), (this._resolve = void 0);
  }
  get() {
    return this._promise;
  }
  pause() {
    var t;
    (null !== (t = this._promise) && void 0 !== t) ||
      (this._promise = new Promise((t) => (this._resolve = t)));
  }
  resume() {
    var t;
    null === (t = this._resolve) || void 0 === t || t.call(this),
      (this._promise = this._resolve = void 0);
  }
}
class Ht extends Mt {
  constructor() {
    super(...arguments),
      (this.__weakThis = new Bt(this)),
      (this.__pauser = new Dt());
  }
  render(t, e) {
    return H;
  }
  update(t, e) {
    let [i, s] = e;
    if ((this.isConnected || this.disconnected(), i === this.__value)) return;
    this.__value = i;
    let n = 0;
    const {__weakThis: r, __pauser: o} = this;
    return (
      Lt(i, async (t) => {
        for (; o.get(); ) await o.get();
        const e = r.deref();
        if (void 0 !== e) {
          if (e.__value !== i) return !1;
          void 0 !== s && (t = s(t, n)), e.commitValue(t, n), n++;
        }
        return !0;
      }),
      H
    );
  }
  commitValue(t, e) {
    this.setValue(t);
  }
  disconnected() {
    this.__weakThis.disconnect(), this.__pauser.pause();
  }
  reconnected() {
    this.__weakThis.reconnect(this), this.__pauser.resume();
  }
}
const Wt = At(Ht);
const Ft = At(
  class extends Ht {
    constructor(t) {
      if ((super(t), t.type !== Et.CHILD))
        throw new Error('asyncAppend can only be used in child expressions');
    }
    update(t, e) {
      return (this.__childPart = t), super.update(t, e);
    }
    commitValue(t, e) {
      0 === e && Vt(this.__childPart);
      const i = wt(this.__childPart);
      Ct(i, t);
    }
  }
);
const Kt = At(
    class extends Nt {
      constructor(t) {
        super(t), (this._templateCache = new WeakMap());
      }
      render(t) {
        return [t];
      }
      update(t, e) {
        let [i] = e;
        if (mt(this._value) && (!mt(i) || this._value.strings !== i.strings)) {
          const e = Tt(t).pop();
          let i = this._templateCache.get(this._value.strings);
          if (void 0 === i) {
            const t = document.createDocumentFragment();
            (i = ot(W, t)),
              i.setConnected(!1),
              this._templateCache.set(this._value.strings, i);
          }
          St(i, [e]), wt(i, void 0, e);
        }
        if (mt(i)) {
          if (!mt(this._value) || this._value.strings !== i.strings) {
            const e = this._templateCache.get(i.strings);
            if (void 0 !== e) {
              const i = Tt(e).pop();
              Vt(t), wt(t, void 0, i), St(t, [i]);
            }
          }
          this._value = i;
        } else this._value = void 0;
        return this.render(i);
      }
    }
  ),
  qt = (t, e, i) => {
    for (const i of e) {
      if (i[0] === t) {
        return (0, i[1])();
      }
    }
    return null == i ? void 0 : i();
  };
const Yt = At(
    class extends Nt {
      constructor(t) {
        var e;
        if (
          (super(t),
          t.type !== Et.ATTRIBUTE ||
            'class' !== t.name ||
            (null === (e = t.strings) || void 0 === e ? void 0 : e.length) > 2)
        )
          throw new Error(
            '`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.'
          );
      }
      render(t) {
        return (
          ' ' +
          Object.keys(t)
            .filter((e) => t[e])
            .join(' ') +
          ' '
        );
      }
      update(t, e) {
        let [i] = e;
        var s, n;
        if (void 0 === this._previousClasses) {
          (this._previousClasses = new Set()),
            void 0 !== t.strings &&
              (this._staticClasses = new Set(
                t.strings
                  .join(' ')
                  .split(/\s/)
                  .filter((t) => '' !== t)
              ));
          for (const t in i)
            i[t] &&
              !(null === (s = this._staticClasses) || void 0 === s
                ? void 0
                : s.has(t)) &&
              this._previousClasses.add(t);
          return this.render(i);
        }
        const r = t.element.classList;
        this._previousClasses.forEach((t) => {
          t in i || (r.remove(t), this._previousClasses.delete(t));
        });
        for (const t in i) {
          const e = !!i[t];
          e === this._previousClasses.has(t) ||
            (null === (n = this._staticClasses) || void 0 === n
              ? void 0
              : n.has(t)) ||
            (e
              ? (r.add(t), this._previousClasses.add(t))
              : (r.remove(t), this._previousClasses.delete(t)));
        }
        return H;
      }
    }
  ),
  Zt = {};
const Gt = At(
    class extends Nt {
      constructor() {
        super(...arguments), (this._previousValue = Zt);
      }
      render(t, e) {
        return e();
      }
      update(t, e) {
        let [i, s] = e;
        if (Array.isArray(i)) {
          if (
            Array.isArray(this._previousValue) &&
            this._previousValue.length === i.length &&
            i.every((t, e) => t === this._previousValue[e])
          )
            return H;
        } else if (this._previousValue === i) return H;
        this._previousValue = Array.isArray(i) ? Array.from(i) : i;
        return this.render(i, s);
      }
    }
  ),
  Jt = (t) => (null != t ? t : W);
function* Qt(t, e) {
  const i = 'function' == typeof e;
  if (void 0 !== t) {
    let s = -1;
    for (const n of t) s > -1 && (yield i ? e(s) : e), s++, yield n;
  }
}
const Xt = At(
  class extends Nt {
    constructor() {
      super(...arguments), (this.key = W);
    }
    render(t, e) {
      return (this.key = t), e;
    }
    update(t, e) {
      let [i, s] = e;
      return i !== this.key && (St(t), (this.key = i)), s;
    }
  }
);
const te = At(
  class extends Nt {
    constructor(t) {
      if (
        (super(t),
        t.type !== Et.PROPERTY &&
          t.type !== Et.ATTRIBUTE &&
          t.type !== Et.BOOLEAN_ATTRIBUTE)
      )
        throw new Error(
          'The `live` directive is not allowed on child or event bindings'
        );
      if (!$t(t))
        throw new Error('`live` bindings can only contain a single expression');
    }
    render(t) {
      return t;
    }
    update(t, e) {
      let [i] = e;
      if (i === H || i === W) return i;
      const s = t.element,
        n = t.name;
      if (t.type === Et.PROPERTY) {
        if (i === s[n]) return H;
      } else if (t.type === Et.BOOLEAN_ATTRIBUTE) {
        if (!!i === s.hasAttribute(n)) return H;
      } else if (t.type === Et.ATTRIBUTE && s.getAttribute(n) === String(i))
        return H;
      return St(t), i;
    }
  }
);
function* ee(t, e) {
  if (void 0 !== t) {
    let i = 0;
    for (const s of t) yield e(s, i++);
  }
}
function ie(t, e) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
  return (function* () {
    const s = void 0 === e ? 0 : t;
    null != e || (e = t);
    for (let t = s; i > 0 ? t < e : e < t; t += i) yield t;
  })();
}
const se = () => new ne();
class ne {}
const re = new WeakMap();
const oe = At(
    class extends Mt {
      render(t) {
        return W;
      }
      update(t, e) {
        let [i] = e;
        var s;
        const n = i !== this._ref;
        return (
          n && void 0 !== this._ref && this._updateRefValue(void 0),
          (n || this._lastElementForRef !== this._element) &&
            ((this._ref = i),
            (this._context =
              null === (s = t.options) || void 0 === s ? void 0 : s.host),
            this._updateRefValue((this._element = t.element))),
          W
        );
      }
      _updateRefValue(t) {
        var e;
        if ('function' == typeof this._ref) {
          const i =
            null !== (e = this._context) && void 0 !== e ? e : globalThis;
          let s = re.get(i);
          void 0 === s && ((s = new WeakMap()), re.set(i, s)),
            void 0 !== s.get(this._ref) &&
              this._ref.call(this._context, void 0),
            s.set(this._ref, t),
            void 0 !== t && this._ref.call(this._context, t);
        } else this._ref.value = t;
      }
      get _lastElementForRef() {
        var t, e, i;
        return 'function' == typeof this._ref
          ? null ===
              (e = re.get(
                null !== (t = this._context) && void 0 !== t ? t : globalThis
              )) || void 0 === e
            ? void 0
            : e.get(this._ref)
          : null === (i = this._ref) || void 0 === i
          ? void 0
          : i.value;
      }
      disconnected() {
        this._lastElementForRef === this._element &&
          this._updateRefValue(void 0);
      }
      reconnected() {
        this._updateRefValue(this._element);
      }
    }
  ),
  le = (t, e, i) => {
    const s = new Map();
    for (let n = e; n <= i; n++) s.set(t[n], n);
    return s;
  };
const ae = At(
    class extends Nt {
      constructor(t) {
        if ((super(t), t.type !== Et.CHILD))
          throw new Error('repeat() can only be used in text expressions');
      }
      _getValuesAndKeys(t, e, i) {
        let s;
        void 0 === i ? (i = e) : void 0 !== e && (s = e);
        const n = [],
          r = [];
        let o = 0;
        for (const e of t) (n[o] = s ? s(e, o) : o), (r[o] = i(e, o)), o++;
        return {values: r, keys: n};
      }
      render(t, e, i) {
        return this._getValuesAndKeys(t, e, i).values;
      }
      update(t, e) {
        let [i, s, n] = e;
        var r;
        const o = Tt(t),
          {values: l, keys: a} = this._getValuesAndKeys(i, s, n);
        if (!Array.isArray(o)) return (this._itemKeys = a), l;
        const c =
            null !== (r = this._itemKeys) && void 0 !== r
              ? r
              : (this._itemKeys = []),
          d = [];
        let h,
          u,
          _ = 0,
          p = o.length - 1,
          v = 0,
          f = l.length - 1;
        for (; _ <= p && v <= f; )
          if (null === o[_]) _++;
          else if (null === o[p]) p--;
          else if (c[_] === a[v]) (d[v] = Ct(o[_], l[v])), _++, v++;
          else if (c[p] === a[f]) (d[f] = Ct(o[p], l[f])), p--, f--;
          else if (c[_] === a[f])
            (d[f] = Ct(o[_], l[f])), wt(t, d[f + 1], o[_]), _++, f--;
          else if (c[p] === a[v])
            (d[v] = Ct(o[p], l[v])), wt(t, o[_], o[p]), p--, v++;
          else if (
            (void 0 === h && ((h = le(a, v, f)), (u = le(c, _, p))),
            h.has(c[_]))
          )
            if (h.has(c[p])) {
              const e = u.get(a[v]),
                i = void 0 !== e ? o[e] : null;
              if (null === i) {
                const e = wt(t, o[_]);
                Ct(e, l[v]), (d[v] = e);
              } else (d[v] = Ct(i, l[v])), wt(t, o[_], i), (o[e] = null);
              v++;
            } else xt(o[p]), p--;
          else xt(o[_]), _++;
        for (; v <= f; ) {
          const e = wt(t, d[f + 1]);
          Ct(e, l[v]), (d[v++] = e);
        }
        for (; _ <= p; ) {
          const t = o[_++];
          null !== t && xt(t);
        }
        return (this._itemKeys = a), St(t, d), H;
      }
    }
  ),
  ce = 'important',
  de = ' !' + ce,
  he = 0 - de.length;
const ue = At(
  class extends Nt {
    constructor(t) {
      var e;
      if (
        (super(t),
        t.type !== Et.ATTRIBUTE ||
          'style' !== t.name ||
          (null === (e = t.strings) || void 0 === e ? void 0 : e.length) > 2)
      )
        throw new Error(
          'The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.'
        );
    }
    render(t) {
      return Object.keys(t).reduce((e, i) => {
        const s = t[i];
        return null == s
          ? e
          : ((i = i.includes('-')
              ? i
              : i
                  .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')
                  .toLowerCase()),
            e + ''.concat(i, ':').concat(s, ';'));
      }, '');
    }
    update(t, e) {
      let [i] = e;
      const {style: s} = t.element;
      if (void 0 === this._previousStyleProperties) {
        this._previousStyleProperties = new Set();
        for (const t in i) this._previousStyleProperties.add(t);
        return this.render(i);
      }
      this._previousStyleProperties.forEach((t) => {
        null == i[t] &&
          (this._previousStyleProperties.delete(t),
          t.includes('-') ? s.removeProperty(t) : (s[t] = ''));
      });
      for (const t in i) {
        const e = i[t];
        if (null != e) {
          this._previousStyleProperties.add(t);
          const i = 'string' == typeof e && e.endsWith(de);
          t.includes('-') || i
            ? s.setProperty(t, i ? e.slice(0, he) : e, i ? ce : '')
            : (s[t] = e);
        }
      }
      return H;
    }
  }
);
const _e = At(
  class extends Nt {
    constructor(t) {
      if ((super(t), t.type !== Et.CHILD))
        throw new Error('templateContent can only be used in child bindings');
    }
    render(t) {
      return this._previousTemplate === t
        ? H
        : ((this._previousTemplate = t), document.importNode(t.content, !0));
    }
  }
);
class pe extends Nt {
  constructor(t) {
    if ((super(t), (this._value = W), t.type !== Et.CHILD))
      throw new Error(
        ''.concat(
          this.constructor.directiveName,
          '() can only be used in child bindings'
        )
      );
  }
  render(t) {
    if (t === W || null == t)
      return (this._templateResult = void 0), (this._value = t);
    if (t === H) return t;
    if ('string' != typeof t)
      throw new Error(
        ''.concat(
          this.constructor.directiveName,
          '() called with a non-string value'
        )
      );
    if (t === this._value) return this._templateResult;
    this._value = t;
    const e = [t];
    return (
      (e.raw = e),
      (this._templateResult = {
        _$litType$: this.constructor.resultType,
        strings: e,
        values: [],
      })
    );
  }
}
(pe.directiveName = 'unsafeHTML'), (pe.resultType = 1);
const ve = At(pe);
class fe extends pe {}
(fe.directiveName = 'unsafeSVG'), (fe.resultType = 2);
const me = At(fe),
  ye = (t) => !vt(t) && 'function' == typeof t.then,
  ge = 1073741823;
class $e extends Mt {
  constructor() {
    super(...arguments),
      (this.__lastRenderedIndex = ge),
      (this.__values = []),
      (this.__weakThis = new Bt(this)),
      (this.__pauser = new Dt());
  }
  render() {
    for (var t, e = arguments.length, i = new Array(e), s = 0; s < e; s++)
      i[s] = arguments[s];
    return null !== (t = i.find((t) => !ye(t))) && void 0 !== t ? t : H;
  }
  update(t, e) {
    const i = this.__values;
    let s = i.length;
    this.__values = e;
    const n = this.__weakThis,
      r = this.__pauser;
    this.isConnected || this.disconnected();
    for (let t = 0; t < e.length && !(t > this.__lastRenderedIndex); t++) {
      const o = e[t];
      if (!ye(o)) return (this.__lastRenderedIndex = t), o;
      (t < s && o === i[t]) ||
        ((this.__lastRenderedIndex = ge),
        (s = 0),
        Promise.resolve(o).then(async (t) => {
          for (; r.get(); ) await r.get();
          const e = n.deref();
          if (void 0 !== e) {
            const i = e.__values.indexOf(o);
            i > -1 &&
              i < e.__lastRenderedIndex &&
              ((e.__lastRenderedIndex = i), e.setValue(t));
          }
        }));
    }
    return H;
  }
  disconnected() {
    this.__weakThis.disconnect(), this.__pauser.pause();
  }
  reconnected() {
    this.__weakThis.reconnect(this), this.__pauser.resume();
  }
}
const be = At($e);
function we(t, e, i) {
  return t ? e() : null == i ? void 0 : i();
}
const Ce = Symbol.for(''),
  Pe = (t) => {
    if ((null == t ? void 0 : t.r) === Ce)
      return null == t ? void 0 : t._$litStatic$;
  },
  Se = (t) => ({_$litStatic$: t, r: Ce}),
  Te = function (t) {
    for (
      var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), s = 1;
      s < e;
      s++
    )
      i[s - 1] = arguments[s];
    return {
      _$litStatic$: i.reduce(
        (e, i, s) =>
          e +
          ((t) => {
            if (void 0 !== t._$litStatic$) return t._$litStatic$;
            throw new Error(
              "Value passed to 'literal' function must be a 'literal' result: ".concat(
                t,
                ". Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security."
              )
            );
          })(i) +
          t[s + 1],
        t[0]
      ),
      r: Ce,
    };
  },
  xe = new Map(),
  Ve = (t) =>
    function (e) {
      for (
        var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), n = 1;
        n < i;
        n++
      )
        s[n - 1] = arguments[n];
      const r = s.length;
      let o, l;
      const a = [],
        c = [];
      let d,
        h = 0,
        u = !1;
      for (; h < r; ) {
        for (d = e[h]; h < r && void 0 !== ((l = s[h]), (o = Pe(l))); )
          (d += o + e[++h]), (u = !0);
        h !== r && c.push(l), a.push(d), h++;
      }
      if ((h === r && a.push(e[r]), u)) {
        const t = a.join('$$lit$$');
        void 0 === (e = xe.get(t)) && ((a.raw = a), xe.set(t, (e = a))),
          (s = c);
      }
      return t(e, ...s);
    },
  Ee = Ve(B),
  Ae = Ve(D);
window.litDisableBundleWarning ||
  console.warn(
    'Lit has been loaded from a bundle that combines all core features into a single file. To reduce transfer size and parsing cost, consider using the `lit` npm package directly in your project.'
  );
export {
  Mt as AsyncDirective,
  Ht as AsyncReplaceDirective,
  n as CSSResult,
  Nt as Directive,
  dt as LitElement,
  Et as PartType,
  y as ReactiveElement,
  ft as TemplateResultType,
  pe as UnsafeHTMLDirective,
  $e as UntilDirective,
  ct as UpdatingElement,
  ut as _$LE,
  nt as _$LH,
  l as adoptStyles,
  Ft as asyncAppend,
  Wt as asyncReplace,
  Kt as cache,
  qt as choose,
  Yt as classMap,
  Vt as clearPart,
  se as createRef,
  o as css,
  p as defaultConverter,
  At as directive,
  Tt as getCommittedValue,
  a as getCompatibleStyle,
  gt as getDirectiveClass,
  Gt as guard,
  B as html,
  Jt as ifDefined,
  wt as insertPart,
  yt as isDirectiveResult,
  vt as isPrimitive,
  _t as isServer,
  $t as isSingleExpression,
  mt as isTemplateResult,
  Qt as join,
  Xt as keyed,
  Te as literal,
  te as live,
  ee as map,
  H as noChange,
  v as notEqual,
  W as nothing,
  ie as range,
  oe as ref,
  xt as removePart,
  ot as render,
  ae as repeat,
  Ct as setChildPartValue,
  St as setCommittedValue,
  Ee as staticHtml,
  Ae as staticSvg,
  ue as styleMap,
  e as supportsAdoptingStyleSheets,
  D as svg,
  _e as templateContent,
  r as unsafeCSS,
  ve as unsafeHTML,
  me as unsafeSVG,
  Se as unsafeStatic,
  be as until,
  we as when,
  Ve as withStatic,
};
//# sourceMappingURL=lit-all.es.min.js.map
