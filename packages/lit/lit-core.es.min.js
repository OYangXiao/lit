import 'core-js/modules/es.global-this.js';
import 'core-js/modules/es.array.flat.js';
import 'core-js/modules/es.array.unscopables.flat.js';
import 'core-js/modules/es.array.unshift.js';
import 'core-js/modules/es.string.trim.js';
const t = window,
  e =
    t.ShadowRoot &&
    (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype,
  i = Symbol(),
  s = new WeakMap();
class r {
  constructor(t, e, s) {
    if (((this._$cssResult$ = !0), s !== i))
      throw new Error(
        'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'
      );
    (this.cssText = t), (this._strings = e);
  }
  get styleSheet() {
    let t = this._styleSheet;
    const i = this._strings;
    if (e && void 0 === t) {
      const e = void 0 !== i && 1 === i.length;
      e && (t = s.get(i)),
        void 0 === t &&
          ((this._styleSheet = t = new CSSStyleSheet()).replaceSync(
            this.cssText
          ),
          e && s.set(i, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
}
const n = (t) => new r('string' == typeof t ? t : String(t), void 0, i),
  o = function (t) {
    for (
      var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), n = 1;
      n < e;
      n++
    )
      s[n - 1] = arguments[n];
    const o =
      1 === t.length
        ? t[0]
        : s.reduce(
            (e, i, s) =>
              e +
              ((t) => {
                if (!0 === t._$cssResult$) return t.cssText;
                if ('number' == typeof t) return t;
                throw new Error(
                  "Value passed to 'css' function must be a 'css' function result: " +
                    ''.concat(
                      t,
                      ". Use 'unsafeCSS' to pass non-literal values, but take care "
                    ) +
                    'to ensure page security.'
                );
              })(i) +
              t[s + 1],
            t[0]
          );
    return new r(o, t, i);
  },
  l = (i, s) => {
    e
      ? (i.adoptedStyleSheets = s.map((t) =>
          t instanceof CSSStyleSheet ? t : t.styleSheet
        ))
      : s.forEach((e) => {
          const s = document.createElement('style'),
            r = t.litNonce;
          void 0 !== r && s.setAttribute('nonce', r),
            (s.textContent = e.cssText),
            i.appendChild(s);
        });
  },
  a = e
    ? (t) => t
    : (t) =>
        t instanceof CSSStyleSheet
          ? ((t) => {
              let e = '';
              for (const i of t.cssRules) e += i.cssText;
              return n(e);
            })(t)
          : t;
var c;
const d = window,
  h = d.trustedTypes,
  u = h ? h.emptyScript : '',
  p = d.reactiveElementPolyfillSupport,
  _ = {
    toAttribute(t, e) {
      switch (e) {
        case Boolean:
          t = t ? u : null;
          break;
        case Object:
        case Array:
          t = null == t ? t : JSON.stringify(t);
      }
      return t;
    },
    fromAttribute(t, e) {
      let i = t;
      switch (e) {
        case Boolean:
          i = null !== t;
          break;
        case Number:
          i = null === t ? null : Number(t);
          break;
        case Object:
        case Array:
          try {
            i = JSON.parse(t);
          } catch (t) {
            i = null;
          }
      }
      return i;
    },
  },
  m = (t, e) => e !== t && (e == e || t == t),
  v = {attribute: !0, type: String, converter: _, reflect: !1, hasChanged: m},
  f = 'finalized';
class g extends HTMLElement {
  constructor() {
    super(),
      (this.__instanceProperties = new Map()),
      (this.isUpdatePending = !1),
      (this.hasUpdated = !1),
      (this.__reflectingProperty = null),
      this._initialize();
  }
  static addInitializer(t) {
    var e;
    this.finalize(),
      (null !== (e = this._initializers) && void 0 !== e
        ? e
        : (this._initializers = [])
      ).push(t);
  }
  static get observedAttributes() {
    this.finalize();
    const t = [];
    return (
      this.elementProperties.forEach((e, i) => {
        const s = this.__attributeNameForProperty(i, e);
        void 0 !== s && (this.__attributeToPropertyMap.set(s, i), t.push(s));
      }),
      t
    );
  }
  static createProperty(t) {
    let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : v;
    if (
      (e.state && (e.attribute = !1),
      this.finalize(),
      this.elementProperties.set(t, e),
      !e.noAccessor && !this.prototype.hasOwnProperty(t))
    ) {
      const i = 'symbol' == typeof t ? Symbol() : '__'.concat(t),
        s = this.getPropertyDescriptor(t, i, e);
      void 0 !== s && Object.defineProperty(this.prototype, t, s);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    return {
      get() {
        return this[e];
      },
      set(s) {
        const r = this[t];
        (this[e] = s), this.requestUpdate(t, r, i);
      },
      configurable: !0,
      enumerable: !0,
    };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) || v;
  }
  static finalize() {
    if (this.hasOwnProperty(f)) return !1;
    this[f] = !0;
    const t = Object.getPrototypeOf(this);
    if (
      (t.finalize(),
      void 0 !== t._initializers && (this._initializers = [...t._initializers]),
      (this.elementProperties = new Map(t.elementProperties)),
      (this.__attributeToPropertyMap = new Map()),
      this.hasOwnProperty('properties'))
    ) {
      const t = this.properties,
        e = [
          ...Object.getOwnPropertyNames(t),
          ...Object.getOwnPropertySymbols(t),
        ];
      for (const i of e) this.createProperty(i, t[i]);
    }
    return (this.elementStyles = this.finalizeStyles(this.styles)), !0;
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const t of i) e.unshift(a(t));
    } else void 0 !== t && e.push(a(t));
    return e;
  }
  static __attributeNameForProperty(t, e) {
    const i = e.attribute;
    return !1 === i
      ? void 0
      : 'string' == typeof i
      ? i
      : 'string' == typeof t
      ? t.toLowerCase()
      : void 0;
  }
  _initialize() {
    var t;
    (this.__updatePromise = new Promise((t) => (this.enableUpdating = t))),
      (this._$changedProperties = new Map()),
      this.__saveInstanceProperties(),
      this.requestUpdate(),
      null === (t = this.constructor._initializers) ||
        void 0 === t ||
        t.forEach((t) => t(this));
  }
  addController(t) {
    var e, i;
    (null !== (e = this.__controllers) && void 0 !== e
      ? e
      : (this.__controllers = [])
    ).push(t),
      void 0 !== this.renderRoot &&
        this.isConnected &&
        (null === (i = t.hostConnected) || void 0 === i || i.call(t));
  }
  removeController(t) {
    var e;
    null === (e = this.__controllers) ||
      void 0 === e ||
      e.splice(this.__controllers.indexOf(t) >>> 0, 1);
  }
  __saveInstanceProperties() {
    this.constructor.elementProperties.forEach((t, e) => {
      this.hasOwnProperty(e) &&
        (this.__instanceProperties.set(e, this[e]), delete this[e]);
    });
  }
  createRenderRoot() {
    var t;
    const e =
      null !== (t = this.shadowRoot) && void 0 !== t
        ? t
        : this.attachShadow(this.constructor.shadowRootOptions);
    return l(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var t;
    void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()),
      this.enableUpdating(!0),
      null === (t = this.__controllers) ||
        void 0 === t ||
        t.forEach((t) => {
          var e;
          return null === (e = t.hostConnected) || void 0 === e
            ? void 0
            : e.call(t);
        });
  }
  enableUpdating(t) {}
  disconnectedCallback() {
    var t;
    null === (t = this.__controllers) ||
      void 0 === t ||
      t.forEach((t) => {
        var e;
        return null === (e = t.hostDisconnected) || void 0 === e
          ? void 0
          : e.call(t);
      });
  }
  attributeChangedCallback(t, e, i) {
    this._$attributeToProperty(t, i);
  }
  __propertyToAttribute(t, e) {
    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : v;
    var s;
    const r = this.constructor.__attributeNameForProperty(t, i);
    if (void 0 !== r && !0 === i.reflect) {
      const n = (
        void 0 !==
        (null === (s = i.converter) || void 0 === s ? void 0 : s.toAttribute)
          ? i.converter
          : _
      ).toAttribute(e, i.type);
      (this.__reflectingProperty = t),
        null == n ? this.removeAttribute(r) : this.setAttribute(r, n),
        (this.__reflectingProperty = null);
    }
  }
  _$attributeToProperty(t, e) {
    var i;
    const s = this.constructor,
      r = s.__attributeToPropertyMap.get(t);
    if (void 0 !== r && this.__reflectingProperty !== r) {
      const t = s.getPropertyOptions(r),
        n =
          'function' == typeof t.converter
            ? {fromAttribute: t.converter}
            : void 0 !==
              (null === (i = t.converter) || void 0 === i
                ? void 0
                : i.fromAttribute)
            ? t.converter
            : _;
      (this.__reflectingProperty = r),
        (this[r] = n.fromAttribute(e, t.type)),
        (this.__reflectingProperty = null);
    }
  }
  requestUpdate(t, e, i) {
    let s = !0;
    if (void 0 !== t) {
      ((i = i || this.constructor.getPropertyOptions(t)).hasChanged || m)(
        this[t],
        e
      )
        ? (this._$changedProperties.has(t) ||
            this._$changedProperties.set(t, e),
          !0 === i.reflect &&
            this.__reflectingProperty !== t &&
            (void 0 === this.__reflectingProperties &&
              (this.__reflectingProperties = new Map()),
            this.__reflectingProperties.set(t, i)))
        : (s = !1);
    }
    !this.isUpdatePending &&
      s &&
      (this.__updatePromise = this.__enqueueUpdate());
  }
  async __enqueueUpdate() {
    this.isUpdatePending = !0;
    try {
      await this.__updatePromise;
    } catch (t) {
      Promise.reject(t);
    }
    const t = this.scheduleUpdate();
    return null != t && (await t), !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var t;
    if (!this.isUpdatePending) return;
    this.hasUpdated,
      this.__instanceProperties &&
        (this.__instanceProperties.forEach((t, e) => (this[e] = t)),
        (this.__instanceProperties = void 0));
    let e = !1;
    const i = this._$changedProperties;
    try {
      (e = this.shouldUpdate(i)),
        e
          ? (this.willUpdate(i),
            null === (t = this.__controllers) ||
              void 0 === t ||
              t.forEach((t) => {
                var e;
                return null === (e = t.hostUpdate) || void 0 === e
                  ? void 0
                  : e.call(t);
              }),
            this.update(i))
          : this.__markUpdated();
    } catch (t) {
      throw ((e = !1), this.__markUpdated(), t);
    }
    e && this._$didUpdate(i);
  }
  willUpdate(t) {}
  _$didUpdate(t) {
    var e;
    null === (e = this.__controllers) ||
      void 0 === e ||
      e.forEach((t) => {
        var e;
        return null === (e = t.hostUpdated) || void 0 === e
          ? void 0
          : e.call(t);
      }),
      this.hasUpdated || ((this.hasUpdated = !0), this.firstUpdated(t)),
      this.updated(t);
  }
  __markUpdated() {
    (this._$changedProperties = new Map()), (this.isUpdatePending = !1);
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this.__updatePromise;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    void 0 !== this.__reflectingProperties &&
      (this.__reflectingProperties.forEach((t, e) =>
        this.__propertyToAttribute(e, this[e], t)
      ),
      (this.__reflectingProperties = void 0)),
      this.__markUpdated();
  }
  updated(t) {}
  firstUpdated(t) {}
}
var y;
(g[f] = !0),
  (g.elementProperties = new Map()),
  (g.elementStyles = []),
  (g.shadowRootOptions = {mode: 'open'}),
  null == p || p({ReactiveElement: g}),
  (null !== (c = d.reactiveElementVersions) && void 0 !== c
    ? c
    : (d.reactiveElementVersions = [])
  ).push('1.6.1');
const $ = window,
  b = $.trustedTypes,
  P = b ? b.createPolicy('lit-html', {createHTML: (t) => t}) : void 0,
  S = '$lit$',
  C = 'lit$'.concat(String(Math.random()).slice(9), '$'),
  w = '?' + C,
  T = '<'.concat(w, '>'),
  V = document,
  x = () => V.createComment(''),
  N = (t) => null === t || ('object' != typeof t && 'function' != typeof t),
  U = Array.isArray,
  E = (t) =>
    U(t) || 'function' == typeof (null == t ? void 0 : t[Symbol.iterator]),
  A = '[ \t\n\f\r]',
  O = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
  R = /-->/g,
  z = />/g,
  k = new RegExp(
    '>|'
      .concat(A, '(?:(')
      .concat('[^\\s"\'>=/]', '+)(')
      .concat(A, '*=')
      .concat(A, '*(?:')
      .concat('[^ \t\n\f\r"\'`<>=]', '|("|\')|))|$)'),
    'g'
  ),
  M = /'/g,
  j = /"/g,
  L = /^(?:script|style|textarea|title)$/i,
  H = (t) =>
    function (e) {
      for (
        var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), r = 1;
        r < i;
        r++
      )
        s[r - 1] = arguments[r];
      return {_$litType$: t, strings: e, values: s};
    },
  I = H(1),
  B = H(2),
  D = Symbol.for('lit-noChange'),
  W = Symbol.for('lit-nothing'),
  q = new WeakMap(),
  F = V.createTreeWalker(V, 129, null, !1),
  J = (t, e) => {
    const i = t.length - 1,
      s = [];
    let r,
      n = 2 === e ? '<svg>' : '',
      o = O;
    for (let e = 0; e < i; e++) {
      const i = t[e];
      let l,
        a,
        c = -1,
        d = 0;
      for (; d < i.length && ((o.lastIndex = d), (a = o.exec(i)), null !== a); )
        (d = o.lastIndex),
          o === O
            ? '!--' === a[1]
              ? (o = R)
              : void 0 !== a[1]
              ? (o = z)
              : void 0 !== a[2]
              ? (L.test(a[2]) && (r = new RegExp('</'.concat(a[2]), 'g')),
                (o = k))
              : void 0 !== a[3] && (o = k)
            : o === k
            ? '>' === a[0]
              ? ((o = null != r ? r : O), (c = -1))
              : void 0 === a[1]
              ? (c = -2)
              : ((c = o.lastIndex - a[2].length),
                (l = a[1]),
                (o = void 0 === a[3] ? k : '"' === a[3] ? j : M))
            : o === j || o === M
            ? (o = k)
            : o === R || o === z
            ? (o = O)
            : ((o = k), (r = void 0));
      const h = o === k && t[e + 1].startsWith('/>') ? ' ' : '';
      n +=
        o === O
          ? i + T
          : c >= 0
          ? (s.push(l), i.slice(0, c) + S + i.slice(c) + C + h)
          : i + C + (-2 === c ? (s.push(void 0), e) : h);
    }
    const l = n + (t[i] || '<?>') + (2 === e ? '</svg>' : '');
    if (!Array.isArray(t) || !t.hasOwnProperty('raw')) {
      throw new Error('invalid template strings array');
    }
    return [void 0 !== P ? P.createHTML(l) : l, s];
  };
class Z {
  constructor(t, e) {
    let i,
      {strings: s, _$litType$: r} = t;
    this.parts = [];
    let n = 0,
      o = 0;
    const l = s.length - 1,
      a = this.parts,
      [c, d] = J(s, r);
    if (
      ((this.el = Z.createElement(c, e)),
      (F.currentNode = this.el.content),
      2 === r)
    ) {
      const t = this.el.content,
        e = t.firstChild;
      e.remove(), t.append(...e.childNodes);
    }
    for (; null !== (i = F.nextNode()) && a.length < l; ) {
      if (1 === i.nodeType) {
        if (i.hasAttributes()) {
          const t = [];
          for (const e of i.getAttributeNames())
            if (e.endsWith(S) || e.startsWith(C)) {
              const s = d[o++];
              if ((t.push(e), void 0 !== s)) {
                const t = i.getAttribute(s.toLowerCase() + S).split(C),
                  e = /([.?@])?(.*)/.exec(s);
                a.push({
                  type: 1,
                  index: n,
                  name: e[2],
                  strings: t,
                  ctor:
                    '.' === e[1]
                      ? Y
                      : '?' === e[1]
                      ? et
                      : '@' === e[1]
                      ? it
                      : X,
                });
              } else a.push({type: 6, index: n});
            }
          for (const e of t) i.removeAttribute(e);
        }
        if (L.test(i.tagName)) {
          const t = i.textContent.split(C),
            e = t.length - 1;
          if (e > 0) {
            i.textContent = b ? b.emptyScript : '';
            for (let s = 0; s < e; s++)
              i.append(t[s], x()), F.nextNode(), a.push({type: 2, index: ++n});
            i.append(t[e], x());
          }
        }
      } else if (8 === i.nodeType) {
        if (i.data === w) a.push({type: 2, index: n});
        else {
          let t = -1;
          for (; -1 !== (t = i.data.indexOf(C, t + 1)); )
            a.push({type: 7, index: n}), (t += C.length - 1);
        }
      }
      n++;
    }
  }
  static createElement(t, e) {
    const i = V.createElement('template');
    return (i.innerHTML = t), i;
  }
}
function G(t, e) {
  let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t,
    s = arguments.length > 3 ? arguments[3] : void 0;
  var r, n, o, l;
  if (e === D) return e;
  let a =
    void 0 !== s
      ? null === (r = i.__directives) || void 0 === r
        ? void 0
        : r[s]
      : i.__directive;
  const c = N(e) ? void 0 : e._$litDirective$;
  return (
    (null == a ? void 0 : a.constructor) !== c &&
      (null ===
        (n = null == a ? void 0 : a._$notifyDirectiveConnectionChanged) ||
        void 0 === n ||
        n.call(a, !1),
      void 0 === c ? (a = void 0) : ((a = new c(t)), a._$initialize(t, i, s)),
      void 0 !== s
        ? ((null !== (o = (l = i).__directives) && void 0 !== o
            ? o
            : (l.__directives = []))[s] = a)
        : (i.__directive = a)),
    void 0 !== a && (e = G(t, a._$resolve(t, e.values), a, s)),
    e
  );
}
class K {
  constructor(t, e) {
    (this._$parts = []),
      (this._$disconnectableChildren = void 0),
      (this._$template = t),
      (this._$parent = e);
  }
  get parentNode() {
    return this._$parent.parentNode;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _clone(t) {
    var e;
    const {
        el: {content: i},
        parts: s,
      } = this._$template,
      r = (
        null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e
          ? e
          : V
      ).importNode(i, !0);
    F.currentNode = r;
    let n = F.nextNode(),
      o = 0,
      l = 0,
      a = s[0];
    for (; void 0 !== a; ) {
      if (o === a.index) {
        let e;
        2 === a.type
          ? (e = new Q(n, n.nextSibling, this, t))
          : 1 === a.type
          ? (e = new a.ctor(n, a.name, a.strings, this, t))
          : 6 === a.type && (e = new st(n, this, t)),
          this._$parts.push(e),
          (a = s[++l]);
      }
      o !== (null == a ? void 0 : a.index) && ((n = F.nextNode()), o++);
    }
    return (F.currentNode = V), r;
  }
  _update(t) {
    let e = 0;
    for (const i of this._$parts)
      void 0 !== i &&
        (void 0 !== i.strings
          ? (i._$setValue(t, i, e), (e += i.strings.length - 2))
          : i._$setValue(t[e])),
        e++;
  }
}
class Q {
  constructor(t, e, i, s) {
    var r;
    (this.type = 2),
      (this._$committedValue = W),
      (this._$disconnectableChildren = void 0),
      (this._$startNode = t),
      (this._$endNode = e),
      (this._$parent = i),
      (this.options = s),
      (this.__isConnected =
        null === (r = null == s ? void 0 : s.isConnected) || void 0 === r || r);
  }
  get _$isConnected() {
    var t, e;
    return null !==
      (e =
        null === (t = this._$parent) || void 0 === t
          ? void 0
          : t._$isConnected) && void 0 !== e
      ? e
      : this.__isConnected;
  }
  get parentNode() {
    let t = this._$startNode.parentNode;
    const e = this._$parent;
    return (
      void 0 !== e &&
        11 === (null == t ? void 0 : t.nodeType) &&
        (t = e.parentNode),
      t
    );
  }
  get startNode() {
    return this._$startNode;
  }
  get endNode() {
    return this._$endNode;
  }
  _$setValue(t) {
    (t = G(
      this,
      t,
      arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this
    )),
      N(t)
        ? t === W || null == t || '' === t
          ? (this._$committedValue !== W && this._$clear(),
            (this._$committedValue = W))
          : t !== this._$committedValue && t !== D && this._commitText(t)
        : void 0 !== t._$litType$
        ? this._commitTemplateResult(t)
        : void 0 !== t.nodeType
        ? this._commitNode(t)
        : E(t)
        ? this._commitIterable(t)
        : this._commitText(t);
  }
  _insert(t) {
    return this._$startNode.parentNode.insertBefore(t, this._$endNode);
  }
  _commitNode(t) {
    this._$committedValue !== t &&
      (this._$clear(), (this._$committedValue = this._insert(t)));
  }
  _commitText(t) {
    if (this._$committedValue !== W && N(this._$committedValue)) {
      this._$startNode.nextSibling.data = t;
    } else this._commitNode(V.createTextNode(t));
    this._$committedValue = t;
  }
  _commitTemplateResult(t) {
    var e;
    const {values: i, _$litType$: s} = t,
      r =
        'number' == typeof s
          ? this._$getTemplate(t)
          : (void 0 === s.el && (s.el = Z.createElement(s.h, this.options)), s);
    if (
      (null === (e = this._$committedValue) || void 0 === e
        ? void 0
        : e._$template) === r
    )
      this._$committedValue._update(i);
    else {
      const t = new K(r, this),
        e = t._clone(this.options);
      t._update(i), this._commitNode(e), (this._$committedValue = t);
    }
  }
  _$getTemplate(t) {
    let e = q.get(t.strings);
    return void 0 === e && q.set(t.strings, (e = new Z(t))), e;
  }
  _commitIterable(t) {
    U(this._$committedValue) || ((this._$committedValue = []), this._$clear());
    const e = this._$committedValue;
    let i,
      s = 0;
    for (const r of t)
      s === e.length
        ? e.push(
            (i = new Q(
              this._insert(x()),
              this._insert(x()),
              this,
              this.options
            ))
          )
        : (i = e[s]),
        i._$setValue(r),
        s++;
    s < e.length &&
      (this._$clear(i && i._$endNode.nextSibling, s), (e.length = s));
  }
  _$clear() {
    let t =
        arguments.length > 0 && void 0 !== arguments[0]
          ? arguments[0]
          : this._$startNode.nextSibling,
      e = arguments.length > 1 ? arguments[1] : void 0;
    var i;
    for (
      null === (i = this._$notifyConnectionChanged) ||
      void 0 === i ||
      i.call(this, !1, !0, e);
      t && t !== this._$endNode;

    ) {
      const e = t.nextSibling;
      t.remove(), (t = e);
    }
  }
  setConnected(t) {
    var e;
    void 0 === this._$parent &&
      ((this.__isConnected = t),
      null === (e = this._$notifyConnectionChanged) ||
        void 0 === e ||
        e.call(this, t));
  }
}
class X {
  constructor(t, e, i, s, r) {
    (this.type = 1),
      (this._$committedValue = W),
      (this._$disconnectableChildren = void 0),
      (this.element = t),
      (this.name = e),
      (this._$parent = s),
      (this.options = r),
      i.length > 2 || '' !== i[0] || '' !== i[1]
        ? ((this._$committedValue = new Array(i.length - 1).fill(new String())),
          (this.strings = i))
        : (this._$committedValue = W);
  }
  get tagName() {
    return this.element.tagName;
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(t) {
    let e =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this,
      i = arguments.length > 2 ? arguments[2] : void 0,
      s = arguments.length > 3 ? arguments[3] : void 0;
    const r = this.strings;
    let n = !1;
    if (void 0 === r)
      (t = G(this, t, e, 0)),
        (n = !N(t) || (t !== this._$committedValue && t !== D)),
        n && (this._$committedValue = t);
    else {
      const s = t;
      let o, l;
      for (t = r[0], o = 0; o < r.length - 1; o++)
        (l = G(this, s[i + o], e, o)),
          l === D && (l = this._$committedValue[o]),
          n || (n = !N(l) || l !== this._$committedValue[o]),
          l === W ? (t = W) : t !== W && (t += (null != l ? l : '') + r[o + 1]),
          (this._$committedValue[o] = l);
    }
    n && !s && this._commitValue(t);
  }
  _commitValue(t) {
    t === W
      ? this.element.removeAttribute(this.name)
      : this.element.setAttribute(this.name, null != t ? t : '');
  }
}
class Y extends X {
  constructor() {
    super(...arguments), (this.type = 3);
  }
  _commitValue(t) {
    this.element[this.name] = t === W ? void 0 : t;
  }
}
const tt = b ? b.emptyScript : '';
class et extends X {
  constructor() {
    super(...arguments), (this.type = 4);
  }
  _commitValue(t) {
    t && t !== W
      ? this.element.setAttribute(this.name, tt)
      : this.element.removeAttribute(this.name);
  }
}
class it extends X {
  constructor(t, e, i, s, r) {
    super(t, e, i, s, r), (this.type = 5);
  }
  _$setValue(t) {
    var e;
    if (
      (t =
        null !==
          (e = G(
            this,
            t,
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : this,
            0
          )) && void 0 !== e
          ? e
          : W) === D
    )
      return;
    const i = this._$committedValue,
      s =
        (t === W && i !== W) ||
        t.capture !== i.capture ||
        t.once !== i.once ||
        t.passive !== i.passive,
      r = t !== W && (i === W || s);
    s && this.element.removeEventListener(this.name, this, i),
      r && this.element.addEventListener(this.name, this, t),
      (this._$committedValue = t);
  }
  handleEvent(t) {
    var e, i;
    'function' == typeof this._$committedValue
      ? this._$committedValue.call(
          null !==
            (i =
              null === (e = this.options) || void 0 === e ? void 0 : e.host) &&
            void 0 !== i
            ? i
            : this.element,
          t
        )
      : this._$committedValue.handleEvent(t);
  }
}
class st {
  constructor(t, e, i) {
    (this.element = t),
      (this.type = 6),
      (this._$disconnectableChildren = void 0),
      (this._$parent = e),
      (this.options = i);
  }
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  _$setValue(t) {
    G(this, t);
  }
}
const rt = {
    _boundAttributeSuffix: S,
    _marker: C,
    _markerMatch: w,
    _HTML_RESULT: 1,
    _getTemplateHtml: J,
    _TemplateInstance: K,
    _isIterable: E,
    _resolveDirective: G,
    _ChildPart: Q,
    _AttributePart: X,
    _BooleanAttributePart: et,
    _EventPart: it,
    _PropertyPart: Y,
    _ElementPart: st,
  },
  nt = $.litHtmlPolyfillSupport;
null == nt || nt(Z, Q),
  (null !== (y = $.litHtmlVersions) && void 0 !== y
    ? y
    : ($.litHtmlVersions = [])
  ).push('2.7.3');
const ot = (t, e, i) => {
  var s, r;
  const n =
    null !== (s = null == i ? void 0 : i.renderBefore) && void 0 !== s ? s : e;
  let o = n._$litPart$;
  if (void 0 === o) {
    const t =
      null !== (r = null == i ? void 0 : i.renderBefore) && void 0 !== r
        ? r
        : null;
    n._$litPart$ = o = new Q(
      e.insertBefore(x(), t),
      t,
      void 0,
      null != i ? i : {}
    );
  }
  return o._$setValue(t), o;
};
var lt, at;
const ct = g;
class dt extends g {
  constructor() {
    super(...arguments),
      (this.renderOptions = {host: this}),
      (this.__childPart = void 0);
  }
  createRenderRoot() {
    var t, e;
    const i = super.createRenderRoot();
    return (
      (null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t) ||
        (e.renderBefore = i.firstChild),
      i
    );
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
      super.update(t),
      (this.__childPart = ot(e, this.renderRoot, this.renderOptions));
  }
  connectedCallback() {
    var t;
    super.connectedCallback(),
      null === (t = this.__childPart) || void 0 === t || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(),
      null === (t = this.__childPart) || void 0 === t || t.setConnected(!1);
  }
  render() {
    return D;
  }
}
(dt.finalized = !0),
  (dt._$litElement$ = !0),
  null === (lt = globalThis.litElementHydrateSupport) ||
    void 0 === lt ||
    lt.call(globalThis, {LitElement: dt});
const ht = globalThis.litElementPolyfillSupport;
null == ht || ht({LitElement: dt});
const ut = {
  _$attributeToProperty: (t, e, i) => {
    t._$attributeToProperty(e, i);
  },
  _$changedProperties: (t) => t._$changedProperties,
};
(null !== (at = globalThis.litElementVersions) && void 0 !== at
  ? at
  : (globalThis.litElementVersions = [])
).push('3.3.2');
const pt = !1;
export {
  r as CSSResult,
  dt as LitElement,
  g as ReactiveElement,
  ct as UpdatingElement,
  ut as _$LE,
  rt as _$LH,
  l as adoptStyles,
  o as css,
  _ as defaultConverter,
  a as getCompatibleStyle,
  I as html,
  pt as isServer,
  D as noChange,
  m as notEqual,
  W as nothing,
  ot as render,
  e as supportsAdoptingStyleSheets,
  B as svg,
  n as unsafeCSS,
};
//# sourceMappingURL=lit-core.es.min.js.map
