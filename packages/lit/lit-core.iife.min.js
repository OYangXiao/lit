var Lit = (function (exports) {
  'use strict';
  const NODE_MODE$1 = false;
  const global$2 = window;
  const supportsAdoptingStyleSheets =
    global$2.ShadowRoot &&
    (global$2.ShadyCSS === undefined || global$2.ShadyCSS.nativeShadow) &&
    'adoptedStyleSheets' in Document.prototype &&
    'replace' in CSSStyleSheet.prototype;
  const constructionToken = Symbol();
  const cssTagCache = new WeakMap();
  class CSSResult {
    constructor(cssText, strings, safeToken) {
      this['_$cssResult$'] = true;
      if (safeToken !== constructionToken) {
        throw new Error(
          'CSSResult is not constructable. Use `unsafeCSS` or `css` instead.'
        );
      }
      this.cssText = cssText;
      this._strings = strings;
    }
    get styleSheet() {
      let styleSheet = this._styleSheet;
      const strings = this._strings;
      if (supportsAdoptingStyleSheets && styleSheet === undefined) {
        const cacheable = strings !== undefined && strings.length === 1;
        if (cacheable) {
          styleSheet = cssTagCache.get(strings);
        }
        if (styleSheet === undefined) {
          (this._styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(
            this.cssText
          );
          if (cacheable) {
            cssTagCache.set(strings, styleSheet);
          }
        }
      }
      return styleSheet;
    }
    toString() {
      return this.cssText;
    }
  }
  const textFromCSSResult = (value) => {
    if (value['_$cssResult$'] === true) {
      return value.cssText;
    } else if (typeof value === 'number') {
      return value;
    } else {
      throw new Error(
        `Value passed to 'css' function must be a 'css' function result: ` +
          `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +
          `to ensure page security.`
      );
    }
  };
  const unsafeCSS = (value) =>
    new CSSResult(
      typeof value === 'string' ? value : String(value),
      undefined,
      constructionToken
    );
  const css = (strings, ...values) => {
    const cssText =
      strings.length === 1
        ? strings[0]
        : values.reduce(
            (acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1],
            strings[0]
          );
    return new CSSResult(cssText, strings, constructionToken);
  };
  const adoptStyles = (renderRoot, styles) => {
    if (supportsAdoptingStyleSheets) {
      renderRoot.adoptedStyleSheets = styles.map((s) =>
        s instanceof CSSStyleSheet ? s : s.styleSheet
      );
    } else {
      styles.forEach((s) => {
        const style = document.createElement('style');
        const nonce = global$2['litNonce'];
        if (nonce !== undefined) {
          style.setAttribute('nonce', nonce);
        }
        style.textContent = s.cssText;
        renderRoot.appendChild(style);
      });
    }
  };
  const cssResultFromStyleSheet = (sheet) => {
    let cssText = '';
    for (const rule of sheet.cssRules) {
      cssText += rule.cssText;
    }
    return unsafeCSS(cssText);
  };
  const getCompatibleStyle =
    supportsAdoptingStyleSheets || NODE_MODE$1
      ? (s) => s
      : (s) => (s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s);
  var _d$1;
  var _e;
  const global$1 = window;
  const trustedTypes$1 = global$1.trustedTypes;
  const emptyStringForBooleanAttribute$1 = trustedTypes$1
    ? trustedTypes$1.emptyScript
    : '';
  const polyfillSupport$2 = global$1.reactiveElementPolyfillSupport;
  const JSCompiler_renameProperty = (prop, _obj) => prop;
  const defaultConverter = {
    toAttribute(value, type) {
      switch (type) {
        case Boolean:
          value = value ? emptyStringForBooleanAttribute$1 : null;
          break;

        case Object:
        case Array:
          value = value == null ? value : JSON.stringify(value);
          break;
      }
      return value;
    },
    fromAttribute(value, type) {
      let fromValue = value;
      switch (type) {
        case Boolean:
          fromValue = value !== null;
          break;

        case Number:
          fromValue = value === null ? null : Number(value);
          break;

        case Object:
        case Array:
          try {
            fromValue = JSON.parse(value);
          } catch (e) {
            fromValue = null;
          }
          break;
      }
      return fromValue;
    },
  };
  const notEqual = (value, old) =>
    old !== value && (old === old || value === value);
  const defaultPropertyDeclaration = {
    attribute: true,
    type: String,
    converter: defaultConverter,
    reflect: false,
    hasChanged: notEqual,
  };
  const finalized = 'finalized';
  class ReactiveElement extends HTMLElement {
    constructor() {
      super();
      this.__instanceProperties = new Map();
      this.isUpdatePending = false;
      this.hasUpdated = false;
      this.__reflectingProperty = null;
      this._initialize();
    }
    static addInitializer(initializer) {
      var _a;
      this.finalize();
      ((_a = this._initializers) !== null && _a !== void 0
        ? _a
        : (this._initializers = [])
      ).push(initializer);
    }
    static get observedAttributes() {
      this.finalize();
      const attributes = [];
      this.elementProperties.forEach((v, p) => {
        const attr = this.__attributeNameForProperty(p, v);
        if (attr !== undefined) {
          this.__attributeToPropertyMap.set(attr, p);
          attributes.push(attr);
        }
      });
      return attributes;
    }
    static createProperty(name, options = defaultPropertyDeclaration) {
      if (options.state) {
        options.attribute = false;
      }
      this.finalize();
      this.elementProperties.set(name, options);
      if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {
        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
        const descriptor = this.getPropertyDescriptor(name, key, options);
        if (descriptor !== undefined) {
          Object.defineProperty(this.prototype, name, descriptor);
        }
      }
    }
    static getPropertyDescriptor(name, key, options) {
      return {
        get() {
          return this[key];
        },
        set(value) {
          const oldValue = this[name];
          this[key] = value;
          this.requestUpdate(name, oldValue, options);
        },
        configurable: true,
        enumerable: true,
      };
    }
    static getPropertyOptions(name) {
      return this.elementProperties.get(name) || defaultPropertyDeclaration;
    }
    static finalize() {
      if (this.hasOwnProperty(finalized)) {
        return false;
      }
      this[finalized] = true;
      const superCtor = Object.getPrototypeOf(this);
      superCtor.finalize();
      if (superCtor._initializers !== undefined) {
        this._initializers = [...superCtor._initializers];
      }
      this.elementProperties = new Map(superCtor.elementProperties);
      this.__attributeToPropertyMap = new Map();
      if (this.hasOwnProperty(JSCompiler_renameProperty('properties'))) {
        const props = this.properties;
        const propKeys = [
          ...Object.getOwnPropertyNames(props),
          ...Object.getOwnPropertySymbols(props),
        ];
        for (const p of propKeys) {
          this.createProperty(p, props[p]);
        }
      }
      this.elementStyles = this.finalizeStyles(this.styles);
      return true;
    }
    static finalizeStyles(styles) {
      const elementStyles = [];
      if (Array.isArray(styles)) {
        const set = new Set(styles.flat(Infinity).reverse());
        for (const s of set) {
          elementStyles.unshift(getCompatibleStyle(s));
        }
      } else if (styles !== undefined) {
        elementStyles.push(getCompatibleStyle(styles));
      }
      return elementStyles;
    }
    static __attributeNameForProperty(name, options) {
      const attribute = options.attribute;
      return attribute === false
        ? undefined
        : typeof attribute === 'string'
        ? attribute
        : typeof name === 'string'
        ? name.toLowerCase()
        : undefined;
    }
    _initialize() {
      var _a;
      this.__updatePromise = new Promise((res) => (this.enableUpdating = res));
      this._$changedProperties = new Map();
      this.__saveInstanceProperties();
      this.requestUpdate();
      (_a = this.constructor._initializers) === null || _a === void 0
        ? void 0
        : _a.forEach((i) => i(this));
    }
    addController(controller) {
      var _a, _b;
      ((_a = this.__controllers) !== null && _a !== void 0
        ? _a
        : (this.__controllers = [])
      ).push(controller);
      if (this.renderRoot !== undefined && this.isConnected) {
        (_b = controller.hostConnected) === null || _b === void 0
          ? void 0
          : _b.call(controller);
      }
    }
    removeController(controller) {
      var _a;
      (_a = this.__controllers) === null || _a === void 0
        ? void 0
        : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);
    }
    __saveInstanceProperties() {
      this.constructor.elementProperties.forEach((_v, p) => {
        if (this.hasOwnProperty(p)) {
          this.__instanceProperties.set(p, this[p]);
          delete this[p];
        }
      });
    }
    createRenderRoot() {
      var _a;
      const renderRoot =
        (_a = this.shadowRoot) !== null && _a !== void 0
          ? _a
          : this.attachShadow(this.constructor.shadowRootOptions);
      adoptStyles(renderRoot, this.constructor.elementStyles);
      return renderRoot;
    }
    connectedCallback() {
      var _a;
      if (this.renderRoot === undefined) {
        this.renderRoot = this.createRenderRoot();
      }
      this.enableUpdating(true);
      (_a = this.__controllers) === null || _a === void 0
        ? void 0
        : _a.forEach((c) => {
            var _a;
            return (_a = c.hostConnected) === null || _a === void 0
              ? void 0
              : _a.call(c);
          });
    }
    enableUpdating(_requestedUpdate) {}
    disconnectedCallback() {
      var _a;
      (_a = this.__controllers) === null || _a === void 0
        ? void 0
        : _a.forEach((c) => {
            var _a;
            return (_a = c.hostDisconnected) === null || _a === void 0
              ? void 0
              : _a.call(c);
          });
    }
    attributeChangedCallback(name, _old, value) {
      this._$attributeToProperty(name, value);
    }
    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
      var _a;
      const attr = this.constructor.__attributeNameForProperty(name, options);
      if (attr !== undefined && options.reflect === true) {
        const converter =
          ((_a = options.converter) === null || _a === void 0
            ? void 0
            : _a.toAttribute) !== undefined
            ? options.converter
            : defaultConverter;
        const attrValue = converter.toAttribute(value, options.type);
        this.__reflectingProperty = name;
        if (attrValue == null) {
          this.removeAttribute(attr);
        } else {
          this.setAttribute(attr, attrValue);
        }
        this.__reflectingProperty = null;
      }
    }
    _$attributeToProperty(name, value) {
      var _a;
      const ctor = this.constructor;
      const propName = ctor.__attributeToPropertyMap.get(name);
      if (propName !== undefined && this.__reflectingProperty !== propName) {
        const options = ctor.getPropertyOptions(propName);
        const converter =
          typeof options.converter === 'function'
            ? {
                fromAttribute: options.converter,
              }
            : ((_a = options.converter) === null || _a === void 0
                ? void 0
                : _a.fromAttribute) !== undefined
            ? options.converter
            : defaultConverter;
        this.__reflectingProperty = propName;
        this[propName] = converter.fromAttribute(value, options.type);
        this.__reflectingProperty = null;
      }
    }
    requestUpdate(name, oldValue, options) {
      let shouldRequestUpdate = true;
      if (name !== undefined) {
        options = options || this.constructor.getPropertyOptions(name);
        const hasChanged = options.hasChanged || notEqual;
        if (hasChanged(this[name], oldValue)) {
          if (!this._$changedProperties.has(name)) {
            this._$changedProperties.set(name, oldValue);
          }
          if (options.reflect === true && this.__reflectingProperty !== name) {
            if (this.__reflectingProperties === undefined) {
              this.__reflectingProperties = new Map();
            }
            this.__reflectingProperties.set(name, options);
          }
        } else {
          shouldRequestUpdate = false;
        }
      }
      if (!this.isUpdatePending && shouldRequestUpdate) {
        this.__updatePromise = this.__enqueueUpdate();
      }
      return undefined;
    }
    async __enqueueUpdate() {
      this.isUpdatePending = true;
      try {
        await this.__updatePromise;
      } catch (e) {
        Promise.reject(e);
      }
      const result = this.scheduleUpdate();
      if (result != null) {
        await result;
      }
      return !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var _b;
      if (!this.isUpdatePending) {
        return;
      }
      if (!this.hasUpdated);
      if (this.__instanceProperties) {
        this.__instanceProperties.forEach((v, p) => (this[p] = v));
        this.__instanceProperties = undefined;
      }
      let shouldUpdate = false;
      const changedProperties = this._$changedProperties;
      try {
        shouldUpdate = this.shouldUpdate(changedProperties);
        if (shouldUpdate) {
          this.willUpdate(changedProperties);
          (_b = this.__controllers) === null || _b === void 0
            ? void 0
            : _b.forEach((c) => {
                var _a;
                return (_a = c.hostUpdate) === null || _a === void 0
                  ? void 0
                  : _a.call(c);
              });
          this.update(changedProperties);
        } else {
          this.__markUpdated();
        }
      } catch (e) {
        shouldUpdate = false;
        this.__markUpdated();
        throw e;
      }
      if (shouldUpdate) {
        this._$didUpdate(changedProperties);
      }
    }
    willUpdate(_changedProperties) {}
    _$didUpdate(changedProperties) {
      var _a;
      (_a = this.__controllers) === null || _a === void 0
        ? void 0
        : _a.forEach((c) => {
            var _a;
            return (_a = c.hostUpdated) === null || _a === void 0
              ? void 0
              : _a.call(c);
          });
      if (!this.hasUpdated) {
        this.hasUpdated = true;
        this.firstUpdated(changedProperties);
      }
      this.updated(changedProperties);
    }
    __markUpdated() {
      this._$changedProperties = new Map();
      this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this.__updatePromise;
    }
    shouldUpdate(_changedProperties) {
      return true;
    }
    update(_changedProperties) {
      if (this.__reflectingProperties !== undefined) {
        this.__reflectingProperties.forEach((v, k) =>
          this.__propertyToAttribute(k, this[k], v)
        );
        this.__reflectingProperties = undefined;
      }
      this.__markUpdated();
    }
    updated(_changedProperties) {}
    firstUpdated(_changedProperties) {}
  }
  _e = finalized;
  ReactiveElement[_e] = true;
  ReactiveElement.elementProperties = new Map();
  ReactiveElement.elementStyles = [];
  ReactiveElement.shadowRootOptions = {
    mode: 'open',
  };
  polyfillSupport$2 === null || polyfillSupport$2 === void 0
    ? void 0
    : polyfillSupport$2({
        ReactiveElement: ReactiveElement,
      });
  ((_d$1 = global$1.reactiveElementVersions) !== null && _d$1 !== void 0
    ? _d$1
    : (global$1.reactiveElementVersions = [])
  ).push('1.6.1');
  var _d;
  const global = window;
  const wrap = (node) => node;
  const trustedTypes = global.trustedTypes;
  const policy = trustedTypes
    ? trustedTypes.createPolicy('lit-html', {
        createHTML: (s) => s,
      })
    : undefined;
  const boundAttributeSuffix = '$lit$';
  const marker = `lit$${String(Math.random()).slice(9)}$`;
  const markerMatch = '?' + marker;
  const nodeMarker = `<${markerMatch}>`;
  const d = document;
  const createMarker = () => d.createComment('');
  const isPrimitive = (value) =>
    value === null || (typeof value != 'object' && typeof value != 'function');
  const isArray = Array.isArray;
  const isIterable = (value) =>
    isArray(value) ||
    typeof (value === null || value === void 0
      ? void 0
      : value[Symbol.iterator]) === 'function';
  const SPACE_CHAR = `[ \t\n\f\r]`;
  const ATTR_VALUE_CHAR = `[^ \t\n\f\r"'\`<>=]`;
  const NAME_CHAR = `[^\\s"'>=/]`;
  const textEndRegex = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  const COMMENT_START = 1;
  const TAG_NAME = 2;
  const DYNAMIC_TAG_NAME = 3;
  const commentEndRegex = /-->/g;
  const comment2EndRegex = />/g;
  const tagEndRegex = new RegExp(
    `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|("|')|))|$)`,
    'g'
  );
  const ENTIRE_MATCH = 0;
  const ATTRIBUTE_NAME = 1;
  const SPACES_AND_EQUALS = 2;
  const QUOTE_CHAR = 3;
  const singleQuoteAttrEndRegex = /'/g;
  const doubleQuoteAttrEndRegex = /"/g;
  const rawTextElement = /^(?:script|style|textarea|title)$/i;
  const HTML_RESULT = 1;
  const SVG_RESULT = 2;
  const ATTRIBUTE_PART = 1;
  const CHILD_PART = 2;
  const PROPERTY_PART = 3;
  const BOOLEAN_ATTRIBUTE_PART = 4;
  const EVENT_PART = 5;
  const ELEMENT_PART = 6;
  const COMMENT_PART = 7;
  const tag =
    (type) =>
    (strings, ...values) => ({
      ['_$litType$']: type,
      strings: strings,
      values: values,
    });
  const html = tag(HTML_RESULT);
  const svg = tag(SVG_RESULT);
  const noChange = Symbol.for('lit-noChange');
  const nothing = Symbol.for('lit-nothing');
  const templateCache = new WeakMap();
  const walker = d.createTreeWalker(d, 129, null, false);
  const getTemplateHtml = (strings, type) => {
    const l = strings.length - 1;
    const attrNames = [];
    let html = type === SVG_RESULT ? '<svg>' : '';
    let rawTextEndRegex;
    let regex = textEndRegex;
    for (let i = 0; i < l; i++) {
      const s = strings[i];
      let attrNameEndIndex = -1;
      let attrName;
      let lastIndex = 0;
      let match;
      while (lastIndex < s.length) {
        regex.lastIndex = lastIndex;
        match = regex.exec(s);
        if (match === null) {
          break;
        }
        lastIndex = regex.lastIndex;
        if (regex === textEndRegex) {
          if (match[COMMENT_START] === '!--') {
            regex = commentEndRegex;
          } else if (match[COMMENT_START] !== undefined) {
            regex = comment2EndRegex;
          } else if (match[TAG_NAME] !== undefined) {
            if (rawTextElement.test(match[TAG_NAME])) {
              rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');
            }
            regex = tagEndRegex;
          } else if (match[DYNAMIC_TAG_NAME] !== undefined) {
            regex = tagEndRegex;
          }
        } else if (regex === tagEndRegex) {
          if (match[ENTIRE_MATCH] === '>') {
            regex =
              rawTextEndRegex !== null && rawTextEndRegex !== void 0
                ? rawTextEndRegex
                : textEndRegex;
            attrNameEndIndex = -1;
          } else if (match[ATTRIBUTE_NAME] === undefined) {
            attrNameEndIndex = -2;
          } else {
            attrNameEndIndex =
              regex.lastIndex - match[SPACES_AND_EQUALS].length;
            attrName = match[ATTRIBUTE_NAME];
            regex =
              match[QUOTE_CHAR] === undefined
                ? tagEndRegex
                : match[QUOTE_CHAR] === '"'
                ? doubleQuoteAttrEndRegex
                : singleQuoteAttrEndRegex;
          }
        } else if (
          regex === doubleQuoteAttrEndRegex ||
          regex === singleQuoteAttrEndRegex
        ) {
          regex = tagEndRegex;
        } else if (regex === commentEndRegex || regex === comment2EndRegex) {
          regex = textEndRegex;
        } else {
          regex = tagEndRegex;
          rawTextEndRegex = undefined;
        }
      }
      const end =
        regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';
      html +=
        regex === textEndRegex
          ? s + nodeMarker
          : attrNameEndIndex >= 0
          ? (attrNames.push(attrName),
            s.slice(0, attrNameEndIndex) +
              boundAttributeSuffix +
              s.slice(attrNameEndIndex)) +
            marker +
            end
          : s +
            marker +
            (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);
    }
    const htmlResult =
      html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');
    if (!Array.isArray(strings) || !strings.hasOwnProperty('raw')) {
      let message = 'invalid template strings array';
      throw new Error(message);
    }
    return [
      policy !== undefined ? policy.createHTML(htmlResult) : htmlResult,
      attrNames,
    ];
  };
  class Template {
    constructor({strings: strings, ['_$litType$']: type}, options) {
      this.parts = [];
      let node;
      let nodeIndex = 0;
      let attrNameIndex = 0;
      const partCount = strings.length - 1;
      const parts = this.parts;
      const [html, attrNames] = getTemplateHtml(strings, type);
      this.el = Template.createElement(html, options);
      walker.currentNode = this.el.content;
      if (type === SVG_RESULT) {
        const content = this.el.content;
        const svgElement = content.firstChild;
        svgElement.remove();
        content.append(...svgElement.childNodes);
      }
      while ((node = walker.nextNode()) !== null && parts.length < partCount) {
        if (node.nodeType === 1) {
          if (node.hasAttributes()) {
            const attrsToRemove = [];
            for (const name of node.getAttributeNames()) {
              if (
                name.endsWith(boundAttributeSuffix) ||
                name.startsWith(marker)
              ) {
                const realName = attrNames[attrNameIndex++];
                attrsToRemove.push(name);
                if (realName !== undefined) {
                  const value = node.getAttribute(
                    realName.toLowerCase() + boundAttributeSuffix
                  );
                  const statics = value.split(marker);
                  const m = /([.?@])?(.*)/.exec(realName);
                  parts.push({
                    type: ATTRIBUTE_PART,
                    index: nodeIndex,
                    name: m[2],
                    strings: statics,
                    ctor:
                      m[1] === '.'
                        ? PropertyPart
                        : m[1] === '?'
                        ? BooleanAttributePart
                        : m[1] === '@'
                        ? EventPart
                        : AttributePart,
                  });
                } else {
                  parts.push({
                    type: ELEMENT_PART,
                    index: nodeIndex,
                  });
                }
              }
            }
            for (const name of attrsToRemove) {
              node.removeAttribute(name);
            }
          }
          if (rawTextElement.test(node.tagName)) {
            const strings = node.textContent.split(marker);
            const lastIndex = strings.length - 1;
            if (lastIndex > 0) {
              node.textContent = trustedTypes ? trustedTypes.emptyScript : '';
              for (let i = 0; i < lastIndex; i++) {
                node.append(strings[i], createMarker());
                walker.nextNode();
                parts.push({
                  type: CHILD_PART,
                  index: ++nodeIndex,
                });
              }
              node.append(strings[lastIndex], createMarker());
            }
          }
        } else if (node.nodeType === 8) {
          const data = node.data;
          if (data === markerMatch) {
            parts.push({
              type: CHILD_PART,
              index: nodeIndex,
            });
          } else {
            let i = -1;
            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
              parts.push({
                type: COMMENT_PART,
                index: nodeIndex,
              });
              i += marker.length - 1;
            }
          }
        }
        nodeIndex++;
      }
    }
    static createElement(html, _options) {
      const el = d.createElement('template');
      el.innerHTML = html;
      return el;
    }
  }
  function resolveDirective(part, value, parent = part, attributeIndex) {
    var _a, _b, _c;
    var _d;
    if (value === noChange) {
      return value;
    }
    let currentDirective =
      attributeIndex !== undefined
        ? (_a = parent.__directives) === null || _a === void 0
          ? void 0
          : _a[attributeIndex]
        : parent.__directive;
    const nextDirectiveConstructor = isPrimitive(value)
      ? undefined
      : value['_$litDirective$'];
    if (
      (currentDirective === null || currentDirective === void 0
        ? void 0
        : currentDirective.constructor) !== nextDirectiveConstructor
    ) {
      (_b =
        currentDirective === null || currentDirective === void 0
          ? void 0
          : currentDirective['_$notifyDirectiveConnectionChanged']) === null ||
      _b === void 0
        ? void 0
        : _b.call(currentDirective, false);
      if (nextDirectiveConstructor === undefined) {
        currentDirective = undefined;
      } else {
        currentDirective = new nextDirectiveConstructor(part);
        currentDirective._$initialize(part, parent, attributeIndex);
      }
      if (attributeIndex !== undefined) {
        ((_c = (_d = parent).__directives) !== null && _c !== void 0
          ? _c
          : (_d.__directives = []))[attributeIndex] = currentDirective;
      } else {
        parent.__directive = currentDirective;
      }
    }
    if (currentDirective !== undefined) {
      value = resolveDirective(
        part,
        currentDirective._$resolve(part, value.values),
        currentDirective,
        attributeIndex
      );
    }
    return value;
  }
  class TemplateInstance {
    constructor(template, parent) {
      this._$parts = [];
      this._$disconnectableChildren = undefined;
      this._$template = template;
      this._$parent = parent;
    }
    get parentNode() {
      return this._$parent.parentNode;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _clone(options) {
      var _a;
      const {
        el: {content: content},
        parts: parts,
      } = this._$template;
      const fragment = (
        (_a =
          options === null || options === void 0
            ? void 0
            : options.creationScope) !== null && _a !== void 0
          ? _a
          : d
      ).importNode(content, true);
      walker.currentNode = fragment;
      let node = walker.nextNode();
      let nodeIndex = 0;
      let partIndex = 0;
      let templatePart = parts[0];
      while (templatePart !== undefined) {
        if (nodeIndex === templatePart.index) {
          let part;
          if (templatePart.type === CHILD_PART) {
            part = new ChildPart(node, node.nextSibling, this, options);
          } else if (templatePart.type === ATTRIBUTE_PART) {
            part = new templatePart.ctor(
              node,
              templatePart.name,
              templatePart.strings,
              this,
              options
            );
          } else if (templatePart.type === ELEMENT_PART) {
            part = new ElementPart(node, this, options);
          }
          this._$parts.push(part);
          templatePart = parts[++partIndex];
        }
        if (
          nodeIndex !==
          (templatePart === null || templatePart === void 0
            ? void 0
            : templatePart.index)
        ) {
          node = walker.nextNode();
          nodeIndex++;
        }
      }
      walker.currentNode = d;
      return fragment;
    }
    _update(values) {
      let i = 0;
      for (const part of this._$parts) {
        if (part !== undefined) {
          if (part.strings !== undefined) {
            part._$setValue(values, part, i);
            i += part.strings.length - 2;
          } else {
            part._$setValue(values[i]);
          }
        }
        i++;
      }
    }
  }
  class ChildPart {
    constructor(startNode, endNode, parent, options) {
      var _a;
      this.type = CHILD_PART;
      this._$committedValue = nothing;
      this._$disconnectableChildren = undefined;
      this._$startNode = startNode;
      this._$endNode = endNode;
      this._$parent = parent;
      this.options = options;
      this.__isConnected =
        (_a =
          options === null || options === void 0
            ? void 0
            : options.isConnected) !== null && _a !== void 0
          ? _a
          : true;
    }
    get _$isConnected() {
      var _a, _b;
      return (_b =
        (_a = this._$parent) === null || _a === void 0
          ? void 0
          : _a._$isConnected) !== null && _b !== void 0
        ? _b
        : this.__isConnected;
    }
    get parentNode() {
      let parentNode = wrap(this._$startNode).parentNode;
      const parent = this._$parent;
      if (
        parent !== undefined &&
        (parentNode === null || parentNode === void 0
          ? void 0
          : parentNode.nodeType) === 11
      ) {
        parentNode = parent.parentNode;
      }
      return parentNode;
    }
    get startNode() {
      return this._$startNode;
    }
    get endNode() {
      return this._$endNode;
    }
    _$setValue(value, directiveParent = this) {
      value = resolveDirective(this, value, directiveParent);
      if (isPrimitive(value)) {
        if (value === nothing || value == null || value === '') {
          if (this._$committedValue !== nothing) {
            this._$clear();
          }
          this._$committedValue = nothing;
        } else if (value !== this._$committedValue && value !== noChange) {
          this._commitText(value);
        }
      } else if (value['_$litType$'] !== undefined) {
        this._commitTemplateResult(value);
      } else if (value.nodeType !== undefined) {
        this._commitNode(value);
      } else if (isIterable(value)) {
        this._commitIterable(value);
      } else {
        this._commitText(value);
      }
    }
    _insert(node) {
      return wrap(wrap(this._$startNode).parentNode).insertBefore(
        node,
        this._$endNode
      );
    }
    _commitNode(value) {
      if (this._$committedValue !== value) {
        this._$clear();
        this._$committedValue = this._insert(value);
      }
    }
    _commitText(value) {
      if (
        this._$committedValue !== nothing &&
        isPrimitive(this._$committedValue)
      ) {
        const node = wrap(this._$startNode).nextSibling;
        node.data = value;
      } else {
        {
          this._commitNode(d.createTextNode(value));
        }
      }
      this._$committedValue = value;
    }
    _commitTemplateResult(result) {
      var _a;
      const {values: values, ['_$litType$']: type} = result;
      const template =
        typeof type === 'number'
          ? this._$getTemplate(result)
          : (type.el === undefined &&
              (type.el = Template.createElement(type.h, this.options)),
            type);
      if (
        ((_a = this._$committedValue) === null || _a === void 0
          ? void 0
          : _a._$template) === template
      ) {
        this._$committedValue._update(values);
      } else {
        const instance = new TemplateInstance(template, this);
        const fragment = instance._clone(this.options);
        instance._update(values);
        this._commitNode(fragment);
        this._$committedValue = instance;
      }
    }
    _$getTemplate(result) {
      let template = templateCache.get(result.strings);
      if (template === undefined) {
        templateCache.set(result.strings, (template = new Template(result)));
      }
      return template;
    }
    _commitIterable(value) {
      if (!isArray(this._$committedValue)) {
        this._$committedValue = [];
        this._$clear();
      }
      const itemParts = this._$committedValue;
      let partIndex = 0;
      let itemPart;
      for (const item of value) {
        if (partIndex === itemParts.length) {
          itemParts.push(
            (itemPart = new ChildPart(
              this._insert(createMarker()),
              this._insert(createMarker()),
              this,
              this.options
            ))
          );
        } else {
          itemPart = itemParts[partIndex];
        }
        itemPart._$setValue(item);
        partIndex++;
      }
      if (partIndex < itemParts.length) {
        this._$clear(
          itemPart && wrap(itemPart._$endNode).nextSibling,
          partIndex
        );
        itemParts.length = partIndex;
      }
    }
    _$clear(start = wrap(this._$startNode).nextSibling, from) {
      var _a;
      (_a = this._$notifyConnectionChanged) === null || _a === void 0
        ? void 0
        : _a.call(this, false, true, from);
      while (start && start !== this._$endNode) {
        const n = wrap(start).nextSibling;
        wrap(start).remove();
        start = n;
      }
    }
    setConnected(isConnected) {
      var _a;
      if (this._$parent === undefined) {
        this.__isConnected = isConnected;
        (_a = this._$notifyConnectionChanged) === null || _a === void 0
          ? void 0
          : _a.call(this, isConnected);
      }
    }
  }
  class AttributePart {
    constructor(element, name, strings, parent, options) {
      this.type = ATTRIBUTE_PART;
      this._$committedValue = nothing;
      this._$disconnectableChildren = undefined;
      this.element = element;
      this.name = name;
      this._$parent = parent;
      this.options = options;
      if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {
        this._$committedValue = new Array(strings.length - 1).fill(
          new String()
        );
        this.strings = strings;
      } else {
        this._$committedValue = nothing;
      }
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value, directiveParent = this, valueIndex, noCommit) {
      const strings = this.strings;
      let change = false;
      if (strings === undefined) {
        value = resolveDirective(this, value, directiveParent, 0);
        change =
          !isPrimitive(value) ||
          (value !== this._$committedValue && value !== noChange);
        if (change) {
          this._$committedValue = value;
        }
      } else {
        const values = value;
        value = strings[0];
        let i, v;
        for (i = 0; i < strings.length - 1; i++) {
          v = resolveDirective(
            this,
            values[valueIndex + i],
            directiveParent,
            i
          );
          if (v === noChange) {
            v = this._$committedValue[i];
          }
          change ||
            (change = !isPrimitive(v) || v !== this._$committedValue[i]);
          if (v === nothing) {
            value = nothing;
          } else if (value !== nothing) {
            value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];
          }
          this._$committedValue[i] = v;
        }
      }
      if (change && !noCommit) {
        this._commitValue(value);
      }
    }
    _commitValue(value) {
      if (value === nothing) {
        wrap(this.element).removeAttribute(this.name);
      } else {
        wrap(this.element).setAttribute(
          this.name,
          value !== null && value !== void 0 ? value : ''
        );
      }
    }
  }
  class PropertyPart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = PROPERTY_PART;
    }
    _commitValue(value) {
      this.element[this.name] = value === nothing ? undefined : value;
    }
  }
  const emptyStringForBooleanAttribute = trustedTypes
    ? trustedTypes.emptyScript
    : '';
  class BooleanAttributePart extends AttributePart {
    constructor() {
      super(...arguments);
      this.type = BOOLEAN_ATTRIBUTE_PART;
    }
    _commitValue(value) {
      if (value && value !== nothing) {
        wrap(this.element).setAttribute(
          this.name,
          emptyStringForBooleanAttribute
        );
      } else {
        wrap(this.element).removeAttribute(this.name);
      }
    }
  }
  class EventPart extends AttributePart {
    constructor(element, name, strings, parent, options) {
      super(element, name, strings, parent, options);
      this.type = EVENT_PART;
    }
    _$setValue(newListener, directiveParent = this) {
      var _a;
      newListener =
        (_a = resolveDirective(this, newListener, directiveParent, 0)) !==
          null && _a !== void 0
          ? _a
          : nothing;
      if (newListener === noChange) {
        return;
      }
      const oldListener = this._$committedValue;
      const shouldRemoveListener =
        (newListener === nothing && oldListener !== nothing) ||
        newListener.capture !== oldListener.capture ||
        newListener.once !== oldListener.once ||
        newListener.passive !== oldListener.passive;
      const shouldAddListener =
        newListener !== nothing &&
        (oldListener === nothing || shouldRemoveListener);
      if (shouldRemoveListener) {
        this.element.removeEventListener(this.name, this, oldListener);
      }
      if (shouldAddListener) {
        this.element.addEventListener(this.name, this, newListener);
      }
      this._$committedValue = newListener;
    }
    handleEvent(event) {
      var _a, _b;
      if (typeof this._$committedValue === 'function') {
        this._$committedValue.call(
          (_b =
            (_a = this.options) === null || _a === void 0
              ? void 0
              : _a.host) !== null && _b !== void 0
            ? _b
            : this.element,
          event
        );
      } else {
        this._$committedValue.handleEvent(event);
      }
    }
  }
  class ElementPart {
    constructor(element, parent, options) {
      this.element = element;
      this.type = ELEMENT_PART;
      this._$disconnectableChildren = undefined;
      this._$parent = parent;
      this.options = options;
    }
    get _$isConnected() {
      return this._$parent._$isConnected;
    }
    _$setValue(value) {
      resolveDirective(this, value);
    }
  }
  const _$LH = {
    _boundAttributeSuffix: boundAttributeSuffix,
    _marker: marker,
    _markerMatch: markerMatch,
    _HTML_RESULT: HTML_RESULT,
    _getTemplateHtml: getTemplateHtml,
    _TemplateInstance: TemplateInstance,
    _isIterable: isIterable,
    _resolveDirective: resolveDirective,
    _ChildPart: ChildPart,
    _AttributePart: AttributePart,
    _BooleanAttributePart: BooleanAttributePart,
    _EventPart: EventPart,
    _PropertyPart: PropertyPart,
    _ElementPart: ElementPart,
  };
  const polyfillSupport$1 = global.litHtmlPolyfillSupport;
  polyfillSupport$1 === null || polyfillSupport$1 === void 0
    ? void 0
    : polyfillSupport$1(Template, ChildPart);
  ((_d = global.litHtmlVersions) !== null && _d !== void 0
    ? _d
    : (global.litHtmlVersions = [])
  ).push('2.7.3');
  const render = (value, container, options) => {
    var _a, _b;
    const partOwnerNode =
      (_a =
        options === null || options === void 0
          ? void 0
          : options.renderBefore) !== null && _a !== void 0
        ? _a
        : container;
    let part = partOwnerNode['_$litPart$'];
    if (part === undefined) {
      const endNode =
        (_b =
          options === null || options === void 0
            ? void 0
            : options.renderBefore) !== null && _b !== void 0
          ? _b
          : null;
      partOwnerNode['_$litPart$'] = part = new ChildPart(
        container.insertBefore(createMarker(), endNode),
        endNode,
        undefined,
        options !== null && options !== void 0 ? options : {}
      );
    }
    part._$setValue(value);
    return part;
  };
  var _b, _c;
  const UpdatingElement = ReactiveElement;
  class LitElement extends ReactiveElement {
    constructor() {
      super(...arguments);
      this.renderOptions = {
        host: this,
      };
      this.__childPart = undefined;
    }
    createRenderRoot() {
      var _a;
      var _b;
      const renderRoot = super.createRenderRoot();
      (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0
        ? _a
        : (_b.renderBefore = renderRoot.firstChild);
      return renderRoot;
    }
    update(changedProperties) {
      const value = this.render();
      if (!this.hasUpdated) {
        this.renderOptions.isConnected = this.isConnected;
      }
      super.update(changedProperties);
      this.__childPart = render(value, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var _a;
      super.connectedCallback();
      (_a = this.__childPart) === null || _a === void 0
        ? void 0
        : _a.setConnected(true);
    }
    disconnectedCallback() {
      var _a;
      super.disconnectedCallback();
      (_a = this.__childPart) === null || _a === void 0
        ? void 0
        : _a.setConnected(false);
    }
    render() {
      return noChange;
    }
  }
  LitElement['finalized'] = true;
  LitElement['_$litElement$'] = true;
  (_b = globalThis.litElementHydrateSupport) === null || _b === void 0
    ? void 0
    : _b.call(globalThis, {
        LitElement: LitElement,
      });
  const polyfillSupport = globalThis.litElementPolyfillSupport;
  polyfillSupport === null || polyfillSupport === void 0
    ? void 0
    : polyfillSupport({
        LitElement: LitElement,
      });
  const _$LE = {
    _$attributeToProperty: (el, name, value) => {
      el._$attributeToProperty(name, value);
    },
    _$changedProperties: (el) => el._$changedProperties,
  };
  ((_c = globalThis.litElementVersions) !== null && _c !== void 0
    ? _c
    : (globalThis.litElementVersions = [])
  ).push('3.3.2');
  const NODE_MODE = false;
  const isServer = NODE_MODE;
  exports.CSSResult = CSSResult;
  exports.LitElement = LitElement;
  exports.ReactiveElement = ReactiveElement;
  exports.UpdatingElement = UpdatingElement;
  exports._$LE = _$LE;
  exports._$LH = _$LH;
  exports.adoptStyles = adoptStyles;
  exports.css = css;
  exports.defaultConverter = defaultConverter;
  exports.getCompatibleStyle = getCompatibleStyle;
  exports.html = html;
  exports.isServer = isServer;
  exports.noChange = noChange;
  exports.notEqual = notEqual;
  exports.nothing = nothing;
  exports.render = render;
  exports.supportsAdoptingStyleSheets = supportsAdoptingStyleSheets;
  exports.svg = svg;
  exports.unsafeCSS = unsafeCSS;
  Object.defineProperty(exports, '__esModule', {
    value: true,
  });
  return exports;
})({});
//# sourceMappingURL=lit-core.iife.min.js.map
